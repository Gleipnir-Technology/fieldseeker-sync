// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
)

// HistoryPool is an object representing the database table.
type HistoryPool struct {
	Comments               null.Val[string]    `db:"comments" `
	Creationdate           null.Val[int64]     `db:"creationdate" `
	Creator                null.Val[string]    `db:"creator" `
	Datesent               null.Val[int64]     `db:"datesent" `
	Datetested             null.Val[int64]     `db:"datetested" `
	Diseasepos             null.Val[string]    `db:"diseasepos" `
	Diseasetested          null.Val[string]    `db:"diseasetested" `
	Editdate               null.Val[int64]     `db:"editdate" `
	Editor                 null.Val[string]    `db:"editor" `
	Gatewaysync            null.Val[int16]     `db:"gatewaysync" `
	Globalid               null.Val[string]    `db:"globalid" `
	Lab                    null.Val[string]    `db:"lab" `
	LabID                  null.Val[string]    `db:"lab_id" `
	Objectid               int32               `db:"objectid,pk" `
	Poolyear               null.Val[int16]     `db:"poolyear" `
	Processed              null.Val[int16]     `db:"processed" `
	Sampleid               null.Val[string]    `db:"sampleid" `
	Survtech               null.Val[string]    `db:"survtech" `
	Testmethod             null.Val[string]    `db:"testmethod" `
	Testtech               null.Val[string]    `db:"testtech" `
	TrapdataID             null.Val[string]    `db:"trapdata_id" `
	Vectorsurvcollectionid null.Val[string]    `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       null.Val[string]    `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   null.Val[string]    `db:"vectorsurvtrapdataid" `
	Created                null.Val[time.Time] `db:"created" `
	CreatedDate            null.Val[int64]     `db:"created_date" `
	CreatedUser            null.Val[string]    `db:"created_user" `
	GeometryX              null.Val[float64]   `db:"geometry_x" `
	GeometryY              null.Val[float64]   `db:"geometry_y" `
	LastEditedDate         null.Val[int64]     `db:"last_edited_date" `
	LastEditedUser         null.Val[string]    `db:"last_edited_user" `
	Version                int32               `db:"version,pk" `
}

// HistoryPoolSlice is an alias for a slice of pointers to HistoryPool.
// This should almost always be used instead of []*HistoryPool.
type HistoryPoolSlice []*HistoryPool

// HistoryPools contains methods to work with the history_pool table
var HistoryPools = psql.NewTablex[*HistoryPool, HistoryPoolSlice, *HistoryPoolSetter]("", "history_pool", buildHistoryPoolColumns("history_pool"))

// HistoryPoolsQuery is a query on the history_pool table
type HistoryPoolsQuery = *psql.ViewQuery[*HistoryPool, HistoryPoolSlice]

func buildHistoryPoolColumns(alias string) historyPoolColumns {
	return historyPoolColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"comments", "creationdate", "creator", "datesent", "datetested", "diseasepos", "diseasetested", "editdate", "editor", "gatewaysync", "globalid", "lab", "lab_id", "objectid", "poolyear", "processed", "sampleid", "survtech", "testmethod", "testtech", "trapdata_id", "vectorsurvcollectionid", "vectorsurvpoolid", "vectorsurvtrapdataid", "created", "created_date", "created_user", "geometry_x", "geometry_y", "last_edited_date", "last_edited_user", "version",
		).WithParent("history_pool"),
		tableAlias:             alias,
		Comments:               psql.Quote(alias, "comments"),
		Creationdate:           psql.Quote(alias, "creationdate"),
		Creator:                psql.Quote(alias, "creator"),
		Datesent:               psql.Quote(alias, "datesent"),
		Datetested:             psql.Quote(alias, "datetested"),
		Diseasepos:             psql.Quote(alias, "diseasepos"),
		Diseasetested:          psql.Quote(alias, "diseasetested"),
		Editdate:               psql.Quote(alias, "editdate"),
		Editor:                 psql.Quote(alias, "editor"),
		Gatewaysync:            psql.Quote(alias, "gatewaysync"),
		Globalid:               psql.Quote(alias, "globalid"),
		Lab:                    psql.Quote(alias, "lab"),
		LabID:                  psql.Quote(alias, "lab_id"),
		Objectid:               psql.Quote(alias, "objectid"),
		Poolyear:               psql.Quote(alias, "poolyear"),
		Processed:              psql.Quote(alias, "processed"),
		Sampleid:               psql.Quote(alias, "sampleid"),
		Survtech:               psql.Quote(alias, "survtech"),
		Testmethod:             psql.Quote(alias, "testmethod"),
		Testtech:               psql.Quote(alias, "testtech"),
		TrapdataID:             psql.Quote(alias, "trapdata_id"),
		Vectorsurvcollectionid: psql.Quote(alias, "vectorsurvcollectionid"),
		Vectorsurvpoolid:       psql.Quote(alias, "vectorsurvpoolid"),
		Vectorsurvtrapdataid:   psql.Quote(alias, "vectorsurvtrapdataid"),
		Created:                psql.Quote(alias, "created"),
		CreatedDate:            psql.Quote(alias, "created_date"),
		CreatedUser:            psql.Quote(alias, "created_user"),
		GeometryX:              psql.Quote(alias, "geometry_x"),
		GeometryY:              psql.Quote(alias, "geometry_y"),
		LastEditedDate:         psql.Quote(alias, "last_edited_date"),
		LastEditedUser:         psql.Quote(alias, "last_edited_user"),
		Version:                psql.Quote(alias, "version"),
	}
}

type historyPoolColumns struct {
	expr.ColumnsExpr
	tableAlias             string
	Comments               psql.Expression
	Creationdate           psql.Expression
	Creator                psql.Expression
	Datesent               psql.Expression
	Datetested             psql.Expression
	Diseasepos             psql.Expression
	Diseasetested          psql.Expression
	Editdate               psql.Expression
	Editor                 psql.Expression
	Gatewaysync            psql.Expression
	Globalid               psql.Expression
	Lab                    psql.Expression
	LabID                  psql.Expression
	Objectid               psql.Expression
	Poolyear               psql.Expression
	Processed              psql.Expression
	Sampleid               psql.Expression
	Survtech               psql.Expression
	Testmethod             psql.Expression
	Testtech               psql.Expression
	TrapdataID             psql.Expression
	Vectorsurvcollectionid psql.Expression
	Vectorsurvpoolid       psql.Expression
	Vectorsurvtrapdataid   psql.Expression
	Created                psql.Expression
	CreatedDate            psql.Expression
	CreatedUser            psql.Expression
	GeometryX              psql.Expression
	GeometryY              psql.Expression
	LastEditedDate         psql.Expression
	LastEditedUser         psql.Expression
	Version                psql.Expression
}

func (c historyPoolColumns) Alias() string {
	return c.tableAlias
}

func (historyPoolColumns) AliasedAs(alias string) historyPoolColumns {
	return buildHistoryPoolColumns(alias)
}

// HistoryPoolSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type HistoryPoolSetter struct {
	Comments               omitnull.Val[string]    `db:"comments" `
	Creationdate           omitnull.Val[int64]     `db:"creationdate" `
	Creator                omitnull.Val[string]    `db:"creator" `
	Datesent               omitnull.Val[int64]     `db:"datesent" `
	Datetested             omitnull.Val[int64]     `db:"datetested" `
	Diseasepos             omitnull.Val[string]    `db:"diseasepos" `
	Diseasetested          omitnull.Val[string]    `db:"diseasetested" `
	Editdate               omitnull.Val[int64]     `db:"editdate" `
	Editor                 omitnull.Val[string]    `db:"editor" `
	Gatewaysync            omitnull.Val[int16]     `db:"gatewaysync" `
	Globalid               omitnull.Val[string]    `db:"globalid" `
	Lab                    omitnull.Val[string]    `db:"lab" `
	LabID                  omitnull.Val[string]    `db:"lab_id" `
	Objectid               omit.Val[int32]         `db:"objectid,pk" `
	Poolyear               omitnull.Val[int16]     `db:"poolyear" `
	Processed              omitnull.Val[int16]     `db:"processed" `
	Sampleid               omitnull.Val[string]    `db:"sampleid" `
	Survtech               omitnull.Val[string]    `db:"survtech" `
	Testmethod             omitnull.Val[string]    `db:"testmethod" `
	Testtech               omitnull.Val[string]    `db:"testtech" `
	TrapdataID             omitnull.Val[string]    `db:"trapdata_id" `
	Vectorsurvcollectionid omitnull.Val[string]    `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       omitnull.Val[string]    `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   omitnull.Val[string]    `db:"vectorsurvtrapdataid" `
	Created                omitnull.Val[time.Time] `db:"created" `
	CreatedDate            omitnull.Val[int64]     `db:"created_date" `
	CreatedUser            omitnull.Val[string]    `db:"created_user" `
	GeometryX              omitnull.Val[float64]   `db:"geometry_x" `
	GeometryY              omitnull.Val[float64]   `db:"geometry_y" `
	LastEditedDate         omitnull.Val[int64]     `db:"last_edited_date" `
	LastEditedUser         omitnull.Val[string]    `db:"last_edited_user" `
	Version                omit.Val[int32]         `db:"version,pk" `
}

func (s HistoryPoolSetter) SetColumns() []string {
	vals := make([]string, 0, 32)
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Datesent.IsUnset() {
		vals = append(vals, "datesent")
	}
	if !s.Datetested.IsUnset() {
		vals = append(vals, "datetested")
	}
	if !s.Diseasepos.IsUnset() {
		vals = append(vals, "diseasepos")
	}
	if !s.Diseasetested.IsUnset() {
		vals = append(vals, "diseasetested")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Gatewaysync.IsUnset() {
		vals = append(vals, "gatewaysync")
	}
	if !s.Globalid.IsUnset() {
		vals = append(vals, "globalid")
	}
	if !s.Lab.IsUnset() {
		vals = append(vals, "lab")
	}
	if !s.LabID.IsUnset() {
		vals = append(vals, "lab_id")
	}
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Poolyear.IsUnset() {
		vals = append(vals, "poolyear")
	}
	if !s.Processed.IsUnset() {
		vals = append(vals, "processed")
	}
	if !s.Sampleid.IsUnset() {
		vals = append(vals, "sampleid")
	}
	if !s.Survtech.IsUnset() {
		vals = append(vals, "survtech")
	}
	if !s.Testmethod.IsUnset() {
		vals = append(vals, "testmethod")
	}
	if !s.Testtech.IsUnset() {
		vals = append(vals, "testtech")
	}
	if !s.TrapdataID.IsUnset() {
		vals = append(vals, "trapdata_id")
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		vals = append(vals, "vectorsurvcollectionid")
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		vals = append(vals, "vectorsurvpoolid")
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		vals = append(vals, "vectorsurvtrapdataid")
	}
	if !s.Created.IsUnset() {
		vals = append(vals, "created")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.GeometryX.IsUnset() {
		vals = append(vals, "geometry_x")
	}
	if !s.GeometryY.IsUnset() {
		vals = append(vals, "geometry_y")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	return vals
}

func (s HistoryPoolSetter) Overwrite(t *HistoryPool) {
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Datesent.IsUnset() {
		t.Datesent = s.Datesent.MustGetNull()
	}
	if !s.Datetested.IsUnset() {
		t.Datetested = s.Datetested.MustGetNull()
	}
	if !s.Diseasepos.IsUnset() {
		t.Diseasepos = s.Diseasepos.MustGetNull()
	}
	if !s.Diseasetested.IsUnset() {
		t.Diseasetested = s.Diseasetested.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Gatewaysync.IsUnset() {
		t.Gatewaysync = s.Gatewaysync.MustGetNull()
	}
	if !s.Globalid.IsUnset() {
		t.Globalid = s.Globalid.MustGetNull()
	}
	if !s.Lab.IsUnset() {
		t.Lab = s.Lab.MustGetNull()
	}
	if !s.LabID.IsUnset() {
		t.LabID = s.LabID.MustGetNull()
	}
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Poolyear.IsUnset() {
		t.Poolyear = s.Poolyear.MustGetNull()
	}
	if !s.Processed.IsUnset() {
		t.Processed = s.Processed.MustGetNull()
	}
	if !s.Sampleid.IsUnset() {
		t.Sampleid = s.Sampleid.MustGetNull()
	}
	if !s.Survtech.IsUnset() {
		t.Survtech = s.Survtech.MustGetNull()
	}
	if !s.Testmethod.IsUnset() {
		t.Testmethod = s.Testmethod.MustGetNull()
	}
	if !s.Testtech.IsUnset() {
		t.Testtech = s.Testtech.MustGetNull()
	}
	if !s.TrapdataID.IsUnset() {
		t.TrapdataID = s.TrapdataID.MustGetNull()
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		t.Vectorsurvcollectionid = s.Vectorsurvcollectionid.MustGetNull()
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		t.Vectorsurvpoolid = s.Vectorsurvpoolid.MustGetNull()
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		t.Vectorsurvtrapdataid = s.Vectorsurvtrapdataid.MustGetNull()
	}
	if !s.Created.IsUnset() {
		t.Created = s.Created.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.GeometryX.IsUnset() {
		t.GeometryX = s.GeometryX.MustGetNull()
	}
	if !s.GeometryY.IsUnset() {
		t.GeometryY = s.GeometryY.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
}

func (s *HistoryPoolSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return HistoryPools.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 32)
		if !s.Comments.IsUnset() {
			vals[0] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[1] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[2] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Datesent.IsUnset() {
			vals[3] = psql.Arg(s.Datesent.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Datetested.IsUnset() {
			vals[4] = psql.Arg(s.Datetested.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Diseasepos.IsUnset() {
			vals[5] = psql.Arg(s.Diseasepos.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Diseasetested.IsUnset() {
			vals[6] = psql.Arg(s.Diseasetested.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[7] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[8] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Gatewaysync.IsUnset() {
			vals[9] = psql.Arg(s.Gatewaysync.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Globalid.IsUnset() {
			vals[10] = psql.Arg(s.Globalid.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Lab.IsUnset() {
			vals[11] = psql.Arg(s.Lab.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.LabID.IsUnset() {
			vals[12] = psql.Arg(s.LabID.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.Objectid.IsValue() {
			vals[13] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Poolyear.IsUnset() {
			vals[14] = psql.Arg(s.Poolyear.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Processed.IsUnset() {
			vals[15] = psql.Arg(s.Processed.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Sampleid.IsUnset() {
			vals[16] = psql.Arg(s.Sampleid.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Survtech.IsUnset() {
			vals[17] = psql.Arg(s.Survtech.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Testmethod.IsUnset() {
			vals[18] = psql.Arg(s.Testmethod.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Testtech.IsUnset() {
			vals[19] = psql.Arg(s.Testtech.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.TrapdataID.IsUnset() {
			vals[20] = psql.Arg(s.TrapdataID.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvcollectionid.IsUnset() {
			vals[21] = psql.Arg(s.Vectorsurvcollectionid.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvpoolid.IsUnset() {
			vals[22] = psql.Arg(s.Vectorsurvpoolid.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvtrapdataid.IsUnset() {
			vals[23] = psql.Arg(s.Vectorsurvtrapdataid.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.Created.IsUnset() {
			vals[24] = psql.Arg(s.Created.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[25] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[26] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.GeometryX.IsUnset() {
			vals[27] = psql.Arg(s.GeometryX.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.GeometryY.IsUnset() {
			vals[28] = psql.Arg(s.GeometryY.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[29] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[30] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[31] = psql.Arg(s.Version.MustGet())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s HistoryPoolSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s HistoryPoolSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 32)

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Datesent.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datesent")...),
			psql.Arg(s.Datesent),
		}})
	}

	if !s.Datetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datetested")...),
			psql.Arg(s.Datetested),
		}})
	}

	if !s.Diseasepos.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasepos")...),
			psql.Arg(s.Diseasepos),
		}})
	}

	if !s.Diseasetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasetested")...),
			psql.Arg(s.Diseasetested),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Gatewaysync.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gatewaysync")...),
			psql.Arg(s.Gatewaysync),
		}})
	}

	if !s.Globalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Lab.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab")...),
			psql.Arg(s.Lab),
		}})
	}

	if !s.LabID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab_id")...),
			psql.Arg(s.LabID),
		}})
	}

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Poolyear.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "poolyear")...),
			psql.Arg(s.Poolyear),
		}})
	}

	if !s.Processed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "processed")...),
			psql.Arg(s.Processed),
		}})
	}

	if !s.Sampleid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sampleid")...),
			psql.Arg(s.Sampleid),
		}})
	}

	if !s.Survtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "survtech")...),
			psql.Arg(s.Survtech),
		}})
	}

	if !s.Testmethod.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testmethod")...),
			psql.Arg(s.Testmethod),
		}})
	}

	if !s.Testtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testtech")...),
			psql.Arg(s.Testtech),
		}})
	}

	if !s.TrapdataID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "trapdata_id")...),
			psql.Arg(s.TrapdataID),
		}})
	}

	if !s.Vectorsurvcollectionid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvcollectionid")...),
			psql.Arg(s.Vectorsurvcollectionid),
		}})
	}

	if !s.Vectorsurvpoolid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvpoolid")...),
			psql.Arg(s.Vectorsurvpoolid),
		}})
	}

	if !s.Vectorsurvtrapdataid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvtrapdataid")...),
			psql.Arg(s.Vectorsurvtrapdataid),
		}})
	}

	if !s.Created.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created")...),
			psql.Arg(s.Created),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.GeometryX.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_x")...),
			psql.Arg(s.GeometryX),
		}})
	}

	if !s.GeometryY.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_y")...),
			psql.Arg(s.GeometryY),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	return exprs
}

// FindHistoryPool retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindHistoryPool(ctx context.Context, exec bob.Executor, ObjectidPK int32, VersionPK int32, cols ...string) (*HistoryPool, error) {
	if len(cols) == 0 {
		return HistoryPools.Query(
			sm.Where(HistoryPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
			sm.Where(HistoryPools.Columns.Version.EQ(psql.Arg(VersionPK))),
		).One(ctx, exec)
	}

	return HistoryPools.Query(
		sm.Where(HistoryPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(HistoryPools.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Columns(HistoryPools.Columns.Only(cols...)),
	).One(ctx, exec)
}

// HistoryPoolExists checks the presence of a single record by primary key
func HistoryPoolExists(ctx context.Context, exec bob.Executor, ObjectidPK int32, VersionPK int32) (bool, error) {
	return HistoryPools.Query(
		sm.Where(HistoryPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(HistoryPools.Columns.Version.EQ(psql.Arg(VersionPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after HistoryPool is retrieved from the database
func (o *HistoryPool) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = HistoryPools.AfterSelectHooks.RunHooks(ctx, exec, HistoryPoolSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = HistoryPools.AfterInsertHooks.RunHooks(ctx, exec, HistoryPoolSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = HistoryPools.AfterUpdateHooks.RunHooks(ctx, exec, HistoryPoolSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = HistoryPools.AfterDeleteHooks.RunHooks(ctx, exec, HistoryPoolSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the HistoryPool
func (o *HistoryPool) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Objectid,
		o.Version,
	)
}

func (o *HistoryPool) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("history_pool", "objectid"), psql.Quote("history_pool", "version")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the HistoryPool
func (o *HistoryPool) Update(ctx context.Context, exec bob.Executor, s *HistoryPoolSetter) error {
	v, err := HistoryPools.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *v

	return nil
}

// Delete deletes a single HistoryPool record with an executor
func (o *HistoryPool) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := HistoryPools.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the HistoryPool using the executor
func (o *HistoryPool) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := HistoryPools.Query(
		sm.Where(HistoryPools.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
		sm.Where(HistoryPools.Columns.Version.EQ(psql.Arg(o.Version))),
	).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

// AfterQueryHook is called after HistoryPoolSlice is retrieved from the database
func (o HistoryPoolSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = HistoryPools.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = HistoryPools.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = HistoryPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = HistoryPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o HistoryPoolSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("history_pool", "objectid"), psql.Quote("history_pool", "version")).In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o HistoryPoolSlice) copyMatchingRows(from ...*HistoryPool) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			if new.Version != old.Version {
				continue
			}

			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o HistoryPoolSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return HistoryPools.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *HistoryPool:
				o.copyMatchingRows(retrieved)
			case []*HistoryPool:
				o.copyMatchingRows(retrieved...)
			case HistoryPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a HistoryPool or a slice of HistoryPool
				// then run the AfterUpdateHooks on the slice
				_, err = HistoryPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o HistoryPoolSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return HistoryPools.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *HistoryPool:
				o.copyMatchingRows(retrieved)
			case []*HistoryPool:
				o.copyMatchingRows(retrieved...)
			case HistoryPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a HistoryPool or a slice of HistoryPool
				// then run the AfterDeleteHooks on the slice
				_, err = HistoryPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o HistoryPoolSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals HistoryPoolSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := HistoryPools.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o HistoryPoolSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := HistoryPools.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o HistoryPoolSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := HistoryPools.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type historyPoolWhere[Q psql.Filterable] struct {
	Comments               psql.WhereNullMod[Q, string]
	Creationdate           psql.WhereNullMod[Q, int64]
	Creator                psql.WhereNullMod[Q, string]
	Datesent               psql.WhereNullMod[Q, int64]
	Datetested             psql.WhereNullMod[Q, int64]
	Diseasepos             psql.WhereNullMod[Q, string]
	Diseasetested          psql.WhereNullMod[Q, string]
	Editdate               psql.WhereNullMod[Q, int64]
	Editor                 psql.WhereNullMod[Q, string]
	Gatewaysync            psql.WhereNullMod[Q, int16]
	Globalid               psql.WhereNullMod[Q, string]
	Lab                    psql.WhereNullMod[Q, string]
	LabID                  psql.WhereNullMod[Q, string]
	Objectid               psql.WhereMod[Q, int32]
	Poolyear               psql.WhereNullMod[Q, int16]
	Processed              psql.WhereNullMod[Q, int16]
	Sampleid               psql.WhereNullMod[Q, string]
	Survtech               psql.WhereNullMod[Q, string]
	Testmethod             psql.WhereNullMod[Q, string]
	Testtech               psql.WhereNullMod[Q, string]
	TrapdataID             psql.WhereNullMod[Q, string]
	Vectorsurvcollectionid psql.WhereNullMod[Q, string]
	Vectorsurvpoolid       psql.WhereNullMod[Q, string]
	Vectorsurvtrapdataid   psql.WhereNullMod[Q, string]
	Created                psql.WhereNullMod[Q, time.Time]
	CreatedDate            psql.WhereNullMod[Q, int64]
	CreatedUser            psql.WhereNullMod[Q, string]
	GeometryX              psql.WhereNullMod[Q, float64]
	GeometryY              psql.WhereNullMod[Q, float64]
	LastEditedDate         psql.WhereNullMod[Q, int64]
	LastEditedUser         psql.WhereNullMod[Q, string]
	Version                psql.WhereMod[Q, int32]
}

func (historyPoolWhere[Q]) AliasedAs(alias string) historyPoolWhere[Q] {
	return buildHistoryPoolWhere[Q](buildHistoryPoolColumns(alias))
}

func buildHistoryPoolWhere[Q psql.Filterable](cols historyPoolColumns) historyPoolWhere[Q] {
	return historyPoolWhere[Q]{
		Comments:               psql.WhereNull[Q, string](cols.Comments),
		Creationdate:           psql.WhereNull[Q, int64](cols.Creationdate),
		Creator:                psql.WhereNull[Q, string](cols.Creator),
		Datesent:               psql.WhereNull[Q, int64](cols.Datesent),
		Datetested:             psql.WhereNull[Q, int64](cols.Datetested),
		Diseasepos:             psql.WhereNull[Q, string](cols.Diseasepos),
		Diseasetested:          psql.WhereNull[Q, string](cols.Diseasetested),
		Editdate:               psql.WhereNull[Q, int64](cols.Editdate),
		Editor:                 psql.WhereNull[Q, string](cols.Editor),
		Gatewaysync:            psql.WhereNull[Q, int16](cols.Gatewaysync),
		Globalid:               psql.WhereNull[Q, string](cols.Globalid),
		Lab:                    psql.WhereNull[Q, string](cols.Lab),
		LabID:                  psql.WhereNull[Q, string](cols.LabID),
		Objectid:               psql.Where[Q, int32](cols.Objectid),
		Poolyear:               psql.WhereNull[Q, int16](cols.Poolyear),
		Processed:              psql.WhereNull[Q, int16](cols.Processed),
		Sampleid:               psql.WhereNull[Q, string](cols.Sampleid),
		Survtech:               psql.WhereNull[Q, string](cols.Survtech),
		Testmethod:             psql.WhereNull[Q, string](cols.Testmethod),
		Testtech:               psql.WhereNull[Q, string](cols.Testtech),
		TrapdataID:             psql.WhereNull[Q, string](cols.TrapdataID),
		Vectorsurvcollectionid: psql.WhereNull[Q, string](cols.Vectorsurvcollectionid),
		Vectorsurvpoolid:       psql.WhereNull[Q, string](cols.Vectorsurvpoolid),
		Vectorsurvtrapdataid:   psql.WhereNull[Q, string](cols.Vectorsurvtrapdataid),
		Created:                psql.WhereNull[Q, time.Time](cols.Created),
		CreatedDate:            psql.WhereNull[Q, int64](cols.CreatedDate),
		CreatedUser:            psql.WhereNull[Q, string](cols.CreatedUser),
		GeometryX:              psql.WhereNull[Q, float64](cols.GeometryX),
		GeometryY:              psql.WhereNull[Q, float64](cols.GeometryY),
		LastEditedDate:         psql.WhereNull[Q, int64](cols.LastEditedDate),
		LastEditedUser:         psql.WhereNull[Q, string](cols.LastEditedUser),
		Version:                psql.Where[Q, int32](cols.Version),
	}
}
