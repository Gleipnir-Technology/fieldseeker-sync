// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// NoteAudio is an object representing the database table.
type NoteAudio struct {
	Created                       time.Time           `db:"created" `
	Deleted                       null.Val[time.Time] `db:"deleted" `
	Duration                      null.Val[float32]   `db:"duration" `
	Transcription                 null.Val[string]    `db:"transcription" `
	Version                       int32               `db:"version,pk" `
	UUID                          string              `db:"uuid,pk" `
	Creator                       int32               `db:"creator" `
	TranscriptionUserEdited       bool                `db:"transcription_user_edited" `
	IsAudioNormalized             bool                `db:"is_audio_normalized" `
	IsTranscodedToOgg             bool                `db:"is_transcoded_to_ogg" `
	HasBeenReviewed               bool                `db:"has_been_reviewed" `
	TranscriptionInternallyEdited bool                `db:"transcription_internally_edited" `
	NeedsFurtherReview            bool                `db:"needs_further_review" `
	DeletedBy                     null.Val[int32]     `db:"deleted_by" `

	R noteAudioR `db:"-" `
}

// NoteAudioSlice is an alias for a slice of pointers to NoteAudio.
// This should almost always be used instead of []*NoteAudio.
type NoteAudioSlice []*NoteAudio

// NoteAudios contains methods to work with the note_audio table
var NoteAudios = psql.NewTablex[*NoteAudio, NoteAudioSlice, *NoteAudioSetter]("", "note_audio", buildNoteAudioColumns("note_audio"))

// NoteAudiosQuery is a query on the note_audio table
type NoteAudiosQuery = *psql.ViewQuery[*NoteAudio, NoteAudioSlice]

// noteAudioR is where relationships are stored.
type noteAudioR struct {
	CreatorUser          *User                    // note_audio.note_audio_creator_fkey
	DeletedByUser        *User                    // note_audio.note_audio_deleted_by_fkey
	NoteAudioBreadcrumbs NoteAudioBreadcrumbSlice // note_audio_breadcrumb.note_audio_breadcrumb_note_audio_version_note_audio_uuid_fkey
	TaskAudioReviews     TaskAudioReviewSlice     // task_audio_review.task_audio_review_note_audio_uuid_note_audio_version_fkey
}

func buildNoteAudioColumns(alias string) noteAudioColumns {
	return noteAudioColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"created", "deleted", "duration", "transcription", "version", "uuid", "creator", "transcription_user_edited", "is_audio_normalized", "is_transcoded_to_ogg", "has_been_reviewed", "transcription_internally_edited", "needs_further_review", "deleted_by",
		).WithParent("note_audio"),
		tableAlias:                    alias,
		Created:                       psql.Quote(alias, "created"),
		Deleted:                       psql.Quote(alias, "deleted"),
		Duration:                      psql.Quote(alias, "duration"),
		Transcription:                 psql.Quote(alias, "transcription"),
		Version:                       psql.Quote(alias, "version"),
		UUID:                          psql.Quote(alias, "uuid"),
		Creator:                       psql.Quote(alias, "creator"),
		TranscriptionUserEdited:       psql.Quote(alias, "transcription_user_edited"),
		IsAudioNormalized:             psql.Quote(alias, "is_audio_normalized"),
		IsTranscodedToOgg:             psql.Quote(alias, "is_transcoded_to_ogg"),
		HasBeenReviewed:               psql.Quote(alias, "has_been_reviewed"),
		TranscriptionInternallyEdited: psql.Quote(alias, "transcription_internally_edited"),
		NeedsFurtherReview:            psql.Quote(alias, "needs_further_review"),
		DeletedBy:                     psql.Quote(alias, "deleted_by"),
	}
}

type noteAudioColumns struct {
	expr.ColumnsExpr
	tableAlias                    string
	Created                       psql.Expression
	Deleted                       psql.Expression
	Duration                      psql.Expression
	Transcription                 psql.Expression
	Version                       psql.Expression
	UUID                          psql.Expression
	Creator                       psql.Expression
	TranscriptionUserEdited       psql.Expression
	IsAudioNormalized             psql.Expression
	IsTranscodedToOgg             psql.Expression
	HasBeenReviewed               psql.Expression
	TranscriptionInternallyEdited psql.Expression
	NeedsFurtherReview            psql.Expression
	DeletedBy                     psql.Expression
}

func (c noteAudioColumns) Alias() string {
	return c.tableAlias
}

func (noteAudioColumns) AliasedAs(alias string) noteAudioColumns {
	return buildNoteAudioColumns(alias)
}

// NoteAudioSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type NoteAudioSetter struct {
	Created                       omit.Val[time.Time]     `db:"created" `
	Deleted                       omitnull.Val[time.Time] `db:"deleted" `
	Duration                      omitnull.Val[float32]   `db:"duration" `
	Transcription                 omitnull.Val[string]    `db:"transcription" `
	Version                       omit.Val[int32]         `db:"version,pk" `
	UUID                          omit.Val[string]        `db:"uuid,pk" `
	Creator                       omit.Val[int32]         `db:"creator" `
	TranscriptionUserEdited       omit.Val[bool]          `db:"transcription_user_edited" `
	IsAudioNormalized             omit.Val[bool]          `db:"is_audio_normalized" `
	IsTranscodedToOgg             omit.Val[bool]          `db:"is_transcoded_to_ogg" `
	HasBeenReviewed               omit.Val[bool]          `db:"has_been_reviewed" `
	TranscriptionInternallyEdited omit.Val[bool]          `db:"transcription_internally_edited" `
	NeedsFurtherReview            omit.Val[bool]          `db:"needs_further_review" `
	DeletedBy                     omitnull.Val[int32]     `db:"deleted_by" `
}

func (s NoteAudioSetter) SetColumns() []string {
	vals := make([]string, 0, 14)
	if s.Created.IsValue() {
		vals = append(vals, "created")
	}
	if !s.Deleted.IsUnset() {
		vals = append(vals, "deleted")
	}
	if !s.Duration.IsUnset() {
		vals = append(vals, "duration")
	}
	if !s.Transcription.IsUnset() {
		vals = append(vals, "transcription")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	if s.UUID.IsValue() {
		vals = append(vals, "uuid")
	}
	if s.Creator.IsValue() {
		vals = append(vals, "creator")
	}
	if s.TranscriptionUserEdited.IsValue() {
		vals = append(vals, "transcription_user_edited")
	}
	if s.IsAudioNormalized.IsValue() {
		vals = append(vals, "is_audio_normalized")
	}
	if s.IsTranscodedToOgg.IsValue() {
		vals = append(vals, "is_transcoded_to_ogg")
	}
	if s.HasBeenReviewed.IsValue() {
		vals = append(vals, "has_been_reviewed")
	}
	if s.TranscriptionInternallyEdited.IsValue() {
		vals = append(vals, "transcription_internally_edited")
	}
	if s.NeedsFurtherReview.IsValue() {
		vals = append(vals, "needs_further_review")
	}
	if !s.DeletedBy.IsUnset() {
		vals = append(vals, "deleted_by")
	}
	return vals
}

func (s NoteAudioSetter) Overwrite(t *NoteAudio) {
	if s.Created.IsValue() {
		t.Created = s.Created.MustGet()
	}
	if !s.Deleted.IsUnset() {
		t.Deleted = s.Deleted.MustGetNull()
	}
	if !s.Duration.IsUnset() {
		t.Duration = s.Duration.MustGetNull()
	}
	if !s.Transcription.IsUnset() {
		t.Transcription = s.Transcription.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
	if s.UUID.IsValue() {
		t.UUID = s.UUID.MustGet()
	}
	if s.Creator.IsValue() {
		t.Creator = s.Creator.MustGet()
	}
	if s.TranscriptionUserEdited.IsValue() {
		t.TranscriptionUserEdited = s.TranscriptionUserEdited.MustGet()
	}
	if s.IsAudioNormalized.IsValue() {
		t.IsAudioNormalized = s.IsAudioNormalized.MustGet()
	}
	if s.IsTranscodedToOgg.IsValue() {
		t.IsTranscodedToOgg = s.IsTranscodedToOgg.MustGet()
	}
	if s.HasBeenReviewed.IsValue() {
		t.HasBeenReviewed = s.HasBeenReviewed.MustGet()
	}
	if s.TranscriptionInternallyEdited.IsValue() {
		t.TranscriptionInternallyEdited = s.TranscriptionInternallyEdited.MustGet()
	}
	if s.NeedsFurtherReview.IsValue() {
		t.NeedsFurtherReview = s.NeedsFurtherReview.MustGet()
	}
	if !s.DeletedBy.IsUnset() {
		t.DeletedBy = s.DeletedBy.MustGetNull()
	}
}

func (s *NoteAudioSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return NoteAudios.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 14)
		if s.Created.IsValue() {
			vals[0] = psql.Arg(s.Created.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Deleted.IsUnset() {
			vals[1] = psql.Arg(s.Deleted.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Duration.IsUnset() {
			vals[2] = psql.Arg(s.Duration.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Transcription.IsUnset() {
			vals[3] = psql.Arg(s.Transcription.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[4] = psql.Arg(s.Version.MustGet())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.UUID.IsValue() {
			vals[5] = psql.Arg(s.UUID.MustGet())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.Creator.IsValue() {
			vals[6] = psql.Arg(s.Creator.MustGet())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.TranscriptionUserEdited.IsValue() {
			vals[7] = psql.Arg(s.TranscriptionUserEdited.MustGet())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.IsAudioNormalized.IsValue() {
			vals[8] = psql.Arg(s.IsAudioNormalized.MustGet())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.IsTranscodedToOgg.IsValue() {
			vals[9] = psql.Arg(s.IsTranscodedToOgg.MustGet())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.HasBeenReviewed.IsValue() {
			vals[10] = psql.Arg(s.HasBeenReviewed.MustGet())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.TranscriptionInternallyEdited.IsValue() {
			vals[11] = psql.Arg(s.TranscriptionInternallyEdited.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.NeedsFurtherReview.IsValue() {
			vals[12] = psql.Arg(s.NeedsFurtherReview.MustGet())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.DeletedBy.IsUnset() {
			vals[13] = psql.Arg(s.DeletedBy.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s NoteAudioSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s NoteAudioSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 14)

	if s.Created.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created")...),
			psql.Arg(s.Created),
		}})
	}

	if !s.Deleted.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "deleted")...),
			psql.Arg(s.Deleted),
		}})
	}

	if !s.Duration.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "duration")...),
			psql.Arg(s.Duration),
		}})
	}

	if !s.Transcription.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "transcription")...),
			psql.Arg(s.Transcription),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	if s.UUID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "uuid")...),
			psql.Arg(s.UUID),
		}})
	}

	if s.Creator.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if s.TranscriptionUserEdited.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "transcription_user_edited")...),
			psql.Arg(s.TranscriptionUserEdited),
		}})
	}

	if s.IsAudioNormalized.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_audio_normalized")...),
			psql.Arg(s.IsAudioNormalized),
		}})
	}

	if s.IsTranscodedToOgg.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_transcoded_to_ogg")...),
			psql.Arg(s.IsTranscodedToOgg),
		}})
	}

	if s.HasBeenReviewed.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "has_been_reviewed")...),
			psql.Arg(s.HasBeenReviewed),
		}})
	}

	if s.TranscriptionInternallyEdited.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "transcription_internally_edited")...),
			psql.Arg(s.TranscriptionInternallyEdited),
		}})
	}

	if s.NeedsFurtherReview.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "needs_further_review")...),
			psql.Arg(s.NeedsFurtherReview),
		}})
	}

	if !s.DeletedBy.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "deleted_by")...),
			psql.Arg(s.DeletedBy),
		}})
	}

	return exprs
}

// FindNoteAudio retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindNoteAudio(ctx context.Context, exec bob.Executor, VersionPK int32, UUIDPK string, cols ...string) (*NoteAudio, error) {
	if len(cols) == 0 {
		return NoteAudios.Query(
			sm.Where(NoteAudios.Columns.Version.EQ(psql.Arg(VersionPK))),
			sm.Where(NoteAudios.Columns.UUID.EQ(psql.Arg(UUIDPK))),
		).One(ctx, exec)
	}

	return NoteAudios.Query(
		sm.Where(NoteAudios.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Where(NoteAudios.Columns.UUID.EQ(psql.Arg(UUIDPK))),
		sm.Columns(NoteAudios.Columns.Only(cols...)),
	).One(ctx, exec)
}

// NoteAudioExists checks the presence of a single record by primary key
func NoteAudioExists(ctx context.Context, exec bob.Executor, VersionPK int32, UUIDPK string) (bool, error) {
	return NoteAudios.Query(
		sm.Where(NoteAudios.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Where(NoteAudios.Columns.UUID.EQ(psql.Arg(UUIDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after NoteAudio is retrieved from the database
func (o *NoteAudio) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = NoteAudios.AfterSelectHooks.RunHooks(ctx, exec, NoteAudioSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = NoteAudios.AfterInsertHooks.RunHooks(ctx, exec, NoteAudioSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = NoteAudios.AfterUpdateHooks.RunHooks(ctx, exec, NoteAudioSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = NoteAudios.AfterDeleteHooks.RunHooks(ctx, exec, NoteAudioSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the NoteAudio
func (o *NoteAudio) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Version,
		o.UUID,
	)
}

func (o *NoteAudio) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("note_audio", "version"), psql.Quote("note_audio", "uuid")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the NoteAudio
func (o *NoteAudio) Update(ctx context.Context, exec bob.Executor, s *NoteAudioSetter) error {
	v, err := NoteAudios.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single NoteAudio record with an executor
func (o *NoteAudio) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := NoteAudios.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the NoteAudio using the executor
func (o *NoteAudio) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := NoteAudios.Query(
		sm.Where(NoteAudios.Columns.Version.EQ(psql.Arg(o.Version))),
		sm.Where(NoteAudios.Columns.UUID.EQ(psql.Arg(o.UUID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after NoteAudioSlice is retrieved from the database
func (o NoteAudioSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = NoteAudios.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = NoteAudios.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = NoteAudios.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = NoteAudios.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o NoteAudioSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("note_audio", "version"), psql.Quote("note_audio", "uuid")).In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o NoteAudioSlice) copyMatchingRows(from ...*NoteAudio) {
	for i, old := range o {
		for _, new := range from {
			if new.Version != old.Version {
				continue
			}
			if new.UUID != old.UUID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o NoteAudioSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return NoteAudios.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *NoteAudio:
				o.copyMatchingRows(retrieved)
			case []*NoteAudio:
				o.copyMatchingRows(retrieved...)
			case NoteAudioSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a NoteAudio or a slice of NoteAudio
				// then run the AfterUpdateHooks on the slice
				_, err = NoteAudios.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o NoteAudioSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return NoteAudios.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *NoteAudio:
				o.copyMatchingRows(retrieved)
			case []*NoteAudio:
				o.copyMatchingRows(retrieved...)
			case NoteAudioSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a NoteAudio or a slice of NoteAudio
				// then run the AfterDeleteHooks on the slice
				_, err = NoteAudios.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o NoteAudioSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals NoteAudioSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := NoteAudios.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o NoteAudioSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := NoteAudios.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o NoteAudioSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := NoteAudios.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// CreatorUser starts a query for related objects on user_
func (o *NoteAudio) CreatorUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(Users.Columns.ID.EQ(psql.Arg(o.Creator))),
	)...)
}

func (os NoteAudioSlice) CreatorUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkCreator := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkCreator = append(pkCreator, o.Creator)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkCreator), "integer[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(Users.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// DeletedByUser starts a query for related objects on user_
func (o *NoteAudio) DeletedByUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(Users.Columns.ID.EQ(psql.Arg(o.DeletedBy))),
	)...)
}

func (os NoteAudioSlice) DeletedByUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkDeletedBy := make(pgtypes.Array[null.Val[int32]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkDeletedBy = append(pkDeletedBy, o.DeletedBy)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkDeletedBy), "integer[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(Users.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// NoteAudioBreadcrumbs starts a query for related objects on note_audio_breadcrumb
func (o *NoteAudio) NoteAudioBreadcrumbs(mods ...bob.Mod[*dialect.SelectQuery]) NoteAudioBreadcrumbsQuery {
	return NoteAudioBreadcrumbs.Query(append(mods,
		sm.Where(NoteAudioBreadcrumbs.Columns.NoteAudioVersion.EQ(psql.Arg(o.Version))), sm.Where(NoteAudioBreadcrumbs.Columns.NoteAudioUUID.EQ(psql.Arg(o.UUID))),
	)...)
}

func (os NoteAudioSlice) NoteAudioBreadcrumbs(mods ...bob.Mod[*dialect.SelectQuery]) NoteAudioBreadcrumbsQuery {
	pkVersion := make(pgtypes.Array[int32], 0, len(os))

	pkUUID := make(pgtypes.Array[string], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkVersion = append(pkVersion, o.Version)
		pkUUID = append(pkUUID, o.UUID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkVersion), "integer[]")),
		psql.F("unnest", psql.Cast(psql.Arg(pkUUID), "text[]")),
	))

	return NoteAudioBreadcrumbs.Query(append(mods,
		sm.Where(psql.Group(NoteAudioBreadcrumbs.Columns.NoteAudioVersion, NoteAudioBreadcrumbs.Columns.NoteAudioUUID).OP("IN", PKArgExpr)),
	)...)
}

// TaskAudioReviews starts a query for related objects on task_audio_review
func (o *NoteAudio) TaskAudioReviews(mods ...bob.Mod[*dialect.SelectQuery]) TaskAudioReviewsQuery {
	return TaskAudioReviews.Query(append(mods,
		sm.Where(TaskAudioReviews.Columns.NoteAudioUUID.EQ(psql.Arg(o.UUID))), sm.Where(TaskAudioReviews.Columns.NoteAudioVersion.EQ(psql.Arg(o.Version))),
	)...)
}

func (os NoteAudioSlice) TaskAudioReviews(mods ...bob.Mod[*dialect.SelectQuery]) TaskAudioReviewsQuery {
	pkUUID := make(pgtypes.Array[string], 0, len(os))

	pkVersion := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkUUID = append(pkUUID, o.UUID)
		pkVersion = append(pkVersion, o.Version)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUUID), "text[]")),
		psql.F("unnest", psql.Cast(psql.Arg(pkVersion), "integer[]")),
	))

	return TaskAudioReviews.Query(append(mods,
		sm.Where(psql.Group(TaskAudioReviews.Columns.NoteAudioUUID, TaskAudioReviews.Columns.NoteAudioVersion).OP("IN", PKArgExpr)),
	)...)
}

func attachNoteAudioCreatorUser0(ctx context.Context, exec bob.Executor, count int, noteAudio0 *NoteAudio, user1 *User) (*NoteAudio, error) {
	setter := &NoteAudioSetter{
		Creator: omit.From(user1.ID),
	}

	err := noteAudio0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachNoteAudioCreatorUser0: %w", err)
	}

	return noteAudio0, nil
}

func (noteAudio0 *NoteAudio) InsertCreatorUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	var err error

	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachNoteAudioCreatorUser0(ctx, exec, 1, noteAudio0, user1)
	if err != nil {
		return err
	}

	noteAudio0.R.CreatorUser = user1

	user1.R.CreatorNoteAudios = append(user1.R.CreatorNoteAudios, noteAudio0)

	return nil
}

func (noteAudio0 *NoteAudio) AttachCreatorUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachNoteAudioCreatorUser0(ctx, exec, 1, noteAudio0, user1)
	if err != nil {
		return err
	}

	noteAudio0.R.CreatorUser = user1

	user1.R.CreatorNoteAudios = append(user1.R.CreatorNoteAudios, noteAudio0)

	return nil
}

func attachNoteAudioDeletedByUser0(ctx context.Context, exec bob.Executor, count int, noteAudio0 *NoteAudio, user1 *User) (*NoteAudio, error) {
	setter := &NoteAudioSetter{
		DeletedBy: omitnull.From(user1.ID),
	}

	err := noteAudio0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachNoteAudioDeletedByUser0: %w", err)
	}

	return noteAudio0, nil
}

func (noteAudio0 *NoteAudio) InsertDeletedByUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	var err error

	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachNoteAudioDeletedByUser0(ctx, exec, 1, noteAudio0, user1)
	if err != nil {
		return err
	}

	noteAudio0.R.DeletedByUser = user1

	user1.R.DeletedByNoteAudios = append(user1.R.DeletedByNoteAudios, noteAudio0)

	return nil
}

func (noteAudio0 *NoteAudio) AttachDeletedByUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachNoteAudioDeletedByUser0(ctx, exec, 1, noteAudio0, user1)
	if err != nil {
		return err
	}

	noteAudio0.R.DeletedByUser = user1

	user1.R.DeletedByNoteAudios = append(user1.R.DeletedByNoteAudios, noteAudio0)

	return nil
}

func insertNoteAudioNoteAudioBreadcrumbs0(ctx context.Context, exec bob.Executor, noteAudioBreadcrumbs1 []*NoteAudioBreadcrumbSetter, noteAudio0 *NoteAudio) (NoteAudioBreadcrumbSlice, error) {
	for i := range noteAudioBreadcrumbs1 {
		noteAudioBreadcrumbs1[i].NoteAudioVersion = omit.From(noteAudio0.Version)
		noteAudioBreadcrumbs1[i].NoteAudioUUID = omit.From(noteAudio0.UUID)
	}

	ret, err := NoteAudioBreadcrumbs.Insert(bob.ToMods(noteAudioBreadcrumbs1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertNoteAudioNoteAudioBreadcrumbs0: %w", err)
	}

	return ret, nil
}

func attachNoteAudioNoteAudioBreadcrumbs0(ctx context.Context, exec bob.Executor, count int, noteAudioBreadcrumbs1 NoteAudioBreadcrumbSlice, noteAudio0 *NoteAudio) (NoteAudioBreadcrumbSlice, error) {
	setter := &NoteAudioBreadcrumbSetter{
		NoteAudioVersion: omit.From(noteAudio0.Version),
		NoteAudioUUID:    omit.From(noteAudio0.UUID),
	}

	err := noteAudioBreadcrumbs1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachNoteAudioNoteAudioBreadcrumbs0: %w", err)
	}

	return noteAudioBreadcrumbs1, nil
}

func (noteAudio0 *NoteAudio) InsertNoteAudioBreadcrumbs(ctx context.Context, exec bob.Executor, related ...*NoteAudioBreadcrumbSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	noteAudioBreadcrumbs1, err := insertNoteAudioNoteAudioBreadcrumbs0(ctx, exec, related, noteAudio0)
	if err != nil {
		return err
	}

	noteAudio0.R.NoteAudioBreadcrumbs = append(noteAudio0.R.NoteAudioBreadcrumbs, noteAudioBreadcrumbs1...)

	for _, rel := range noteAudioBreadcrumbs1 {
		rel.R.NoteAudio = noteAudio0
	}
	return nil
}

func (noteAudio0 *NoteAudio) AttachNoteAudioBreadcrumbs(ctx context.Context, exec bob.Executor, related ...*NoteAudioBreadcrumb) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	noteAudioBreadcrumbs1 := NoteAudioBreadcrumbSlice(related)

	_, err = attachNoteAudioNoteAudioBreadcrumbs0(ctx, exec, len(related), noteAudioBreadcrumbs1, noteAudio0)
	if err != nil {
		return err
	}

	noteAudio0.R.NoteAudioBreadcrumbs = append(noteAudio0.R.NoteAudioBreadcrumbs, noteAudioBreadcrumbs1...)

	for _, rel := range related {
		rel.R.NoteAudio = noteAudio0
	}

	return nil
}

func insertNoteAudioTaskAudioReviews0(ctx context.Context, exec bob.Executor, taskAudioReviews1 []*TaskAudioReviewSetter, noteAudio0 *NoteAudio) (TaskAudioReviewSlice, error) {
	for i := range taskAudioReviews1 {
		taskAudioReviews1[i].NoteAudioUUID = omit.From(noteAudio0.UUID)
		taskAudioReviews1[i].NoteAudioVersion = omit.From(noteAudio0.Version)
	}

	ret, err := TaskAudioReviews.Insert(bob.ToMods(taskAudioReviews1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertNoteAudioTaskAudioReviews0: %w", err)
	}

	return ret, nil
}

func attachNoteAudioTaskAudioReviews0(ctx context.Context, exec bob.Executor, count int, taskAudioReviews1 TaskAudioReviewSlice, noteAudio0 *NoteAudio) (TaskAudioReviewSlice, error) {
	setter := &TaskAudioReviewSetter{
		NoteAudioUUID:    omit.From(noteAudio0.UUID),
		NoteAudioVersion: omit.From(noteAudio0.Version),
	}

	err := taskAudioReviews1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachNoteAudioTaskAudioReviews0: %w", err)
	}

	return taskAudioReviews1, nil
}

func (noteAudio0 *NoteAudio) InsertTaskAudioReviews(ctx context.Context, exec bob.Executor, related ...*TaskAudioReviewSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	taskAudioReviews1, err := insertNoteAudioTaskAudioReviews0(ctx, exec, related, noteAudio0)
	if err != nil {
		return err
	}

	noteAudio0.R.TaskAudioReviews = append(noteAudio0.R.TaskAudioReviews, taskAudioReviews1...)

	for _, rel := range taskAudioReviews1 {
		rel.R.NoteAudio = noteAudio0
	}
	return nil
}

func (noteAudio0 *NoteAudio) AttachTaskAudioReviews(ctx context.Context, exec bob.Executor, related ...*TaskAudioReview) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	taskAudioReviews1 := TaskAudioReviewSlice(related)

	_, err = attachNoteAudioTaskAudioReviews0(ctx, exec, len(related), taskAudioReviews1, noteAudio0)
	if err != nil {
		return err
	}

	noteAudio0.R.TaskAudioReviews = append(noteAudio0.R.TaskAudioReviews, taskAudioReviews1...)

	for _, rel := range related {
		rel.R.NoteAudio = noteAudio0
	}

	return nil
}

type noteAudioWhere[Q psql.Filterable] struct {
	Created                       psql.WhereMod[Q, time.Time]
	Deleted                       psql.WhereNullMod[Q, time.Time]
	Duration                      psql.WhereNullMod[Q, float32]
	Transcription                 psql.WhereNullMod[Q, string]
	Version                       psql.WhereMod[Q, int32]
	UUID                          psql.WhereMod[Q, string]
	Creator                       psql.WhereMod[Q, int32]
	TranscriptionUserEdited       psql.WhereMod[Q, bool]
	IsAudioNormalized             psql.WhereMod[Q, bool]
	IsTranscodedToOgg             psql.WhereMod[Q, bool]
	HasBeenReviewed               psql.WhereMod[Q, bool]
	TranscriptionInternallyEdited psql.WhereMod[Q, bool]
	NeedsFurtherReview            psql.WhereMod[Q, bool]
	DeletedBy                     psql.WhereNullMod[Q, int32]
}

func (noteAudioWhere[Q]) AliasedAs(alias string) noteAudioWhere[Q] {
	return buildNoteAudioWhere[Q](buildNoteAudioColumns(alias))
}

func buildNoteAudioWhere[Q psql.Filterable](cols noteAudioColumns) noteAudioWhere[Q] {
	return noteAudioWhere[Q]{
		Created:                       psql.Where[Q, time.Time](cols.Created),
		Deleted:                       psql.WhereNull[Q, time.Time](cols.Deleted),
		Duration:                      psql.WhereNull[Q, float32](cols.Duration),
		Transcription:                 psql.WhereNull[Q, string](cols.Transcription),
		Version:                       psql.Where[Q, int32](cols.Version),
		UUID:                          psql.Where[Q, string](cols.UUID),
		Creator:                       psql.Where[Q, int32](cols.Creator),
		TranscriptionUserEdited:       psql.Where[Q, bool](cols.TranscriptionUserEdited),
		IsAudioNormalized:             psql.Where[Q, bool](cols.IsAudioNormalized),
		IsTranscodedToOgg:             psql.Where[Q, bool](cols.IsTranscodedToOgg),
		HasBeenReviewed:               psql.Where[Q, bool](cols.HasBeenReviewed),
		TranscriptionInternallyEdited: psql.Where[Q, bool](cols.TranscriptionInternallyEdited),
		NeedsFurtherReview:            psql.Where[Q, bool](cols.NeedsFurtherReview),
		DeletedBy:                     psql.WhereNull[Q, int32](cols.DeletedBy),
	}
}

func (o *NoteAudio) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "CreatorUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("noteAudio cannot load %T as %q", retrieved, name)
		}

		o.R.CreatorUser = rel

		if rel != nil {
			rel.R.CreatorNoteAudios = NoteAudioSlice{o}
		}
		return nil
	case "DeletedByUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("noteAudio cannot load %T as %q", retrieved, name)
		}

		o.R.DeletedByUser = rel

		if rel != nil {
			rel.R.DeletedByNoteAudios = NoteAudioSlice{o}
		}
		return nil
	case "NoteAudioBreadcrumbs":
		rels, ok := retrieved.(NoteAudioBreadcrumbSlice)
		if !ok {
			return fmt.Errorf("noteAudio cannot load %T as %q", retrieved, name)
		}

		o.R.NoteAudioBreadcrumbs = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.NoteAudio = o
			}
		}
		return nil
	case "TaskAudioReviews":
		rels, ok := retrieved.(TaskAudioReviewSlice)
		if !ok {
			return fmt.Errorf("noteAudio cannot load %T as %q", retrieved, name)
		}

		o.R.TaskAudioReviews = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.NoteAudio = o
			}
		}
		return nil
	default:
		return fmt.Errorf("noteAudio has no relationship %q", name)
	}
}

type noteAudioPreloader struct {
	CreatorUser   func(...psql.PreloadOption) psql.Preloader
	DeletedByUser func(...psql.PreloadOption) psql.Preloader
}

func buildNoteAudioPreloader() noteAudioPreloader {
	return noteAudioPreloader{
		CreatorUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](psql.PreloadRel{
				Name: "CreatorUser",
				Sides: []psql.PreloadSide{
					{
						From:        NoteAudios,
						To:          Users,
						FromColumns: []string{"creator"},
						ToColumns:   []string{"id"},
					},
				},
			}, Users.Columns.Names(), opts...)
		},
		DeletedByUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](psql.PreloadRel{
				Name: "DeletedByUser",
				Sides: []psql.PreloadSide{
					{
						From:        NoteAudios,
						To:          Users,
						FromColumns: []string{"deleted_by"},
						ToColumns:   []string{"id"},
					},
				},
			}, Users.Columns.Names(), opts...)
		},
	}
}

type noteAudioThenLoader[Q orm.Loadable] struct {
	CreatorUser          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	DeletedByUser        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	NoteAudioBreadcrumbs func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	TaskAudioReviews     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildNoteAudioThenLoader[Q orm.Loadable]() noteAudioThenLoader[Q] {
	type CreatorUserLoadInterface interface {
		LoadCreatorUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type DeletedByUserLoadInterface interface {
		LoadDeletedByUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NoteAudioBreadcrumbsLoadInterface interface {
		LoadNoteAudioBreadcrumbs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TaskAudioReviewsLoadInterface interface {
		LoadTaskAudioReviews(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return noteAudioThenLoader[Q]{
		CreatorUser: thenLoadBuilder[Q](
			"CreatorUser",
			func(ctx context.Context, exec bob.Executor, retrieved CreatorUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCreatorUser(ctx, exec, mods...)
			},
		),
		DeletedByUser: thenLoadBuilder[Q](
			"DeletedByUser",
			func(ctx context.Context, exec bob.Executor, retrieved DeletedByUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadDeletedByUser(ctx, exec, mods...)
			},
		),
		NoteAudioBreadcrumbs: thenLoadBuilder[Q](
			"NoteAudioBreadcrumbs",
			func(ctx context.Context, exec bob.Executor, retrieved NoteAudioBreadcrumbsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadNoteAudioBreadcrumbs(ctx, exec, mods...)
			},
		),
		TaskAudioReviews: thenLoadBuilder[Q](
			"TaskAudioReviews",
			func(ctx context.Context, exec bob.Executor, retrieved TaskAudioReviewsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTaskAudioReviews(ctx, exec, mods...)
			},
		),
	}
}

// LoadCreatorUser loads the noteAudio's CreatorUser into the .R struct
func (o *NoteAudio) LoadCreatorUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatorUser = nil

	related, err := o.CreatorUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.CreatorNoteAudios = NoteAudioSlice{o}

	o.R.CreatorUser = related
	return nil
}

// LoadCreatorUser loads the noteAudio's CreatorUser into the .R struct
func (os NoteAudioSlice) LoadCreatorUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.CreatorUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range users {

			if !(o.Creator == rel.ID) {
				continue
			}

			rel.R.CreatorNoteAudios = append(rel.R.CreatorNoteAudios, o)

			o.R.CreatorUser = rel
			break
		}
	}

	return nil
}

// LoadDeletedByUser loads the noteAudio's DeletedByUser into the .R struct
func (o *NoteAudio) LoadDeletedByUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.DeletedByUser = nil

	related, err := o.DeletedByUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.DeletedByNoteAudios = NoteAudioSlice{o}

	o.R.DeletedByUser = related
	return nil
}

// LoadDeletedByUser loads the noteAudio's DeletedByUser into the .R struct
func (os NoteAudioSlice) LoadDeletedByUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.DeletedByUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range users {
			if !o.DeletedBy.IsValue() {
				continue
			}

			if !(o.DeletedBy.IsValue() && o.DeletedBy.MustGet() == rel.ID) {
				continue
			}

			rel.R.DeletedByNoteAudios = append(rel.R.DeletedByNoteAudios, o)

			o.R.DeletedByUser = rel
			break
		}
	}

	return nil
}

// LoadNoteAudioBreadcrumbs loads the noteAudio's NoteAudioBreadcrumbs into the .R struct
func (o *NoteAudio) LoadNoteAudioBreadcrumbs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.NoteAudioBreadcrumbs = nil

	related, err := o.NoteAudioBreadcrumbs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.NoteAudio = o
	}

	o.R.NoteAudioBreadcrumbs = related
	return nil
}

// LoadNoteAudioBreadcrumbs loads the noteAudio's NoteAudioBreadcrumbs into the .R struct
func (os NoteAudioSlice) LoadNoteAudioBreadcrumbs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	noteAudioBreadcrumbs, err := os.NoteAudioBreadcrumbs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.NoteAudioBreadcrumbs = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range noteAudioBreadcrumbs {

			if !(o.Version == rel.NoteAudioVersion) {
				continue
			}

			if !(o.UUID == rel.NoteAudioUUID) {
				continue
			}

			rel.R.NoteAudio = o

			o.R.NoteAudioBreadcrumbs = append(o.R.NoteAudioBreadcrumbs, rel)
		}
	}

	return nil
}

// LoadTaskAudioReviews loads the noteAudio's TaskAudioReviews into the .R struct
func (o *NoteAudio) LoadTaskAudioReviews(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.TaskAudioReviews = nil

	related, err := o.TaskAudioReviews(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.NoteAudio = o
	}

	o.R.TaskAudioReviews = related
	return nil
}

// LoadTaskAudioReviews loads the noteAudio's TaskAudioReviews into the .R struct
func (os NoteAudioSlice) LoadTaskAudioReviews(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	taskAudioReviews, err := os.TaskAudioReviews(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.TaskAudioReviews = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range taskAudioReviews {

			if !(o.UUID == rel.NoteAudioUUID) {
				continue
			}

			if !(o.Version == rel.NoteAudioVersion) {
				continue
			}

			rel.R.NoteAudio = o

			o.R.TaskAudioReviews = append(o.R.TaskAudioReviews, rel)
		}
	}

	return nil
}

type noteAudioJoins[Q dialect.Joinable] struct {
	typ                  string
	CreatorUser          modAs[Q, userColumns]
	DeletedByUser        modAs[Q, userColumns]
	NoteAudioBreadcrumbs modAs[Q, noteAudioBreadcrumbColumns]
	TaskAudioReviews     modAs[Q, taskAudioReviewColumns]
}

func (j noteAudioJoins[Q]) aliasedAs(alias string) noteAudioJoins[Q] {
	return buildNoteAudioJoins[Q](buildNoteAudioColumns(alias), j.typ)
}

func buildNoteAudioJoins[Q dialect.Joinable](cols noteAudioColumns, typ string) noteAudioJoins[Q] {
	return noteAudioJoins[Q]{
		typ: typ,
		CreatorUser: modAs[Q, userColumns]{
			c: Users.Columns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.ID.EQ(cols.Creator),
					))
				}

				return mods
			},
		},
		DeletedByUser: modAs[Q, userColumns]{
			c: Users.Columns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.ID.EQ(cols.DeletedBy),
					))
				}

				return mods
			},
		},
		NoteAudioBreadcrumbs: modAs[Q, noteAudioBreadcrumbColumns]{
			c: NoteAudioBreadcrumbs.Columns,
			f: func(to noteAudioBreadcrumbColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, NoteAudioBreadcrumbs.Name().As(to.Alias())).On(
						to.NoteAudioVersion.EQ(cols.Version), to.NoteAudioUUID.EQ(cols.UUID),
					))
				}

				return mods
			},
		},
		TaskAudioReviews: modAs[Q, taskAudioReviewColumns]{
			c: TaskAudioReviews.Columns,
			f: func(to taskAudioReviewColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, TaskAudioReviews.Name().As(to.Alias())).On(
						to.NoteAudioUUID.EQ(cols.UUID), to.NoteAudioVersion.EQ(cols.Version),
					))
				}

				return mods
			},
		},
	}
}
