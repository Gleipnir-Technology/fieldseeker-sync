// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
)

// HistoryTimecard is an object representing the database table.
type HistoryTimecard struct {
	Activity       null.Val[string]    `db:"activity" `
	Comments       null.Val[string]    `db:"comments" `
	Creationdate   null.Val[int64]     `db:"creationdate" `
	Creator        null.Val[string]    `db:"creator" `
	Enddatetime    null.Val[int64]     `db:"enddatetime" `
	Equiptype      null.Val[string]    `db:"equiptype" `
	Externalid     null.Val[string]    `db:"externalid" `
	Editdate       null.Val[int64]     `db:"editdate" `
	Editor         null.Val[string]    `db:"editor" `
	Fieldtech      null.Val[string]    `db:"fieldtech" `
	Globalid       null.Val[string]    `db:"globalid" `
	Lclocid        null.Val[string]    `db:"lclocid" `
	Linelocid      null.Val[string]    `db:"linelocid" `
	Locationname   null.Val[string]    `db:"locationname" `
	Objectid       int32               `db:"objectid,pk" `
	Pointlocid     null.Val[string]    `db:"pointlocid" `
	Polygonlocid   null.Val[string]    `db:"polygonlocid" `
	Samplelocid    null.Val[string]    `db:"samplelocid" `
	Srid           null.Val[string]    `db:"srid" `
	Startdatetime  null.Val[int64]     `db:"startdatetime" `
	Traplocid      null.Val[string]    `db:"traplocid" `
	Zone           null.Val[string]    `db:"zone" `
	Zone2          null.Val[string]    `db:"zone2" `
	Created        null.Val[time.Time] `db:"created" `
	CreatedDate    null.Val[int64]     `db:"created_date" `
	CreatedUser    null.Val[string]    `db:"created_user" `
	GeometryX      null.Val[float64]   `db:"geometry_x" `
	GeometryY      null.Val[float64]   `db:"geometry_y" `
	LastEditedDate null.Val[int64]     `db:"last_edited_date" `
	LastEditedUser null.Val[string]    `db:"last_edited_user" `
	Version        int32               `db:"version,pk" `
}

// HistoryTimecardSlice is an alias for a slice of pointers to HistoryTimecard.
// This should almost always be used instead of []*HistoryTimecard.
type HistoryTimecardSlice []*HistoryTimecard

// HistoryTimecards contains methods to work with the history_timecard table
var HistoryTimecards = psql.NewTablex[*HistoryTimecard, HistoryTimecardSlice, *HistoryTimecardSetter]("", "history_timecard", buildHistoryTimecardColumns("history_timecard"))

// HistoryTimecardsQuery is a query on the history_timecard table
type HistoryTimecardsQuery = *psql.ViewQuery[*HistoryTimecard, HistoryTimecardSlice]

func buildHistoryTimecardColumns(alias string) historyTimecardColumns {
	return historyTimecardColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"activity", "comments", "creationdate", "creator", "enddatetime", "equiptype", "externalid", "editdate", "editor", "fieldtech", "globalid", "lclocid", "linelocid", "locationname", "objectid", "pointlocid", "polygonlocid", "samplelocid", "srid", "startdatetime", "traplocid", "zone", "zone2", "created", "created_date", "created_user", "geometry_x", "geometry_y", "last_edited_date", "last_edited_user", "version",
		).WithParent("history_timecard"),
		tableAlias:     alias,
		Activity:       psql.Quote(alias, "activity"),
		Comments:       psql.Quote(alias, "comments"),
		Creationdate:   psql.Quote(alias, "creationdate"),
		Creator:        psql.Quote(alias, "creator"),
		Enddatetime:    psql.Quote(alias, "enddatetime"),
		Equiptype:      psql.Quote(alias, "equiptype"),
		Externalid:     psql.Quote(alias, "externalid"),
		Editdate:       psql.Quote(alias, "editdate"),
		Editor:         psql.Quote(alias, "editor"),
		Fieldtech:      psql.Quote(alias, "fieldtech"),
		Globalid:       psql.Quote(alias, "globalid"),
		Lclocid:        psql.Quote(alias, "lclocid"),
		Linelocid:      psql.Quote(alias, "linelocid"),
		Locationname:   psql.Quote(alias, "locationname"),
		Objectid:       psql.Quote(alias, "objectid"),
		Pointlocid:     psql.Quote(alias, "pointlocid"),
		Polygonlocid:   psql.Quote(alias, "polygonlocid"),
		Samplelocid:    psql.Quote(alias, "samplelocid"),
		Srid:           psql.Quote(alias, "srid"),
		Startdatetime:  psql.Quote(alias, "startdatetime"),
		Traplocid:      psql.Quote(alias, "traplocid"),
		Zone:           psql.Quote(alias, "zone"),
		Zone2:          psql.Quote(alias, "zone2"),
		Created:        psql.Quote(alias, "created"),
		CreatedDate:    psql.Quote(alias, "created_date"),
		CreatedUser:    psql.Quote(alias, "created_user"),
		GeometryX:      psql.Quote(alias, "geometry_x"),
		GeometryY:      psql.Quote(alias, "geometry_y"),
		LastEditedDate: psql.Quote(alias, "last_edited_date"),
		LastEditedUser: psql.Quote(alias, "last_edited_user"),
		Version:        psql.Quote(alias, "version"),
	}
}

type historyTimecardColumns struct {
	expr.ColumnsExpr
	tableAlias     string
	Activity       psql.Expression
	Comments       psql.Expression
	Creationdate   psql.Expression
	Creator        psql.Expression
	Enddatetime    psql.Expression
	Equiptype      psql.Expression
	Externalid     psql.Expression
	Editdate       psql.Expression
	Editor         psql.Expression
	Fieldtech      psql.Expression
	Globalid       psql.Expression
	Lclocid        psql.Expression
	Linelocid      psql.Expression
	Locationname   psql.Expression
	Objectid       psql.Expression
	Pointlocid     psql.Expression
	Polygonlocid   psql.Expression
	Samplelocid    psql.Expression
	Srid           psql.Expression
	Startdatetime  psql.Expression
	Traplocid      psql.Expression
	Zone           psql.Expression
	Zone2          psql.Expression
	Created        psql.Expression
	CreatedDate    psql.Expression
	CreatedUser    psql.Expression
	GeometryX      psql.Expression
	GeometryY      psql.Expression
	LastEditedDate psql.Expression
	LastEditedUser psql.Expression
	Version        psql.Expression
}

func (c historyTimecardColumns) Alias() string {
	return c.tableAlias
}

func (historyTimecardColumns) AliasedAs(alias string) historyTimecardColumns {
	return buildHistoryTimecardColumns(alias)
}

// HistoryTimecardSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type HistoryTimecardSetter struct {
	Activity       omitnull.Val[string]    `db:"activity" `
	Comments       omitnull.Val[string]    `db:"comments" `
	Creationdate   omitnull.Val[int64]     `db:"creationdate" `
	Creator        omitnull.Val[string]    `db:"creator" `
	Enddatetime    omitnull.Val[int64]     `db:"enddatetime" `
	Equiptype      omitnull.Val[string]    `db:"equiptype" `
	Externalid     omitnull.Val[string]    `db:"externalid" `
	Editdate       omitnull.Val[int64]     `db:"editdate" `
	Editor         omitnull.Val[string]    `db:"editor" `
	Fieldtech      omitnull.Val[string]    `db:"fieldtech" `
	Globalid       omitnull.Val[string]    `db:"globalid" `
	Lclocid        omitnull.Val[string]    `db:"lclocid" `
	Linelocid      omitnull.Val[string]    `db:"linelocid" `
	Locationname   omitnull.Val[string]    `db:"locationname" `
	Objectid       omit.Val[int32]         `db:"objectid,pk" `
	Pointlocid     omitnull.Val[string]    `db:"pointlocid" `
	Polygonlocid   omitnull.Val[string]    `db:"polygonlocid" `
	Samplelocid    omitnull.Val[string]    `db:"samplelocid" `
	Srid           omitnull.Val[string]    `db:"srid" `
	Startdatetime  omitnull.Val[int64]     `db:"startdatetime" `
	Traplocid      omitnull.Val[string]    `db:"traplocid" `
	Zone           omitnull.Val[string]    `db:"zone" `
	Zone2          omitnull.Val[string]    `db:"zone2" `
	Created        omitnull.Val[time.Time] `db:"created" `
	CreatedDate    omitnull.Val[int64]     `db:"created_date" `
	CreatedUser    omitnull.Val[string]    `db:"created_user" `
	GeometryX      omitnull.Val[float64]   `db:"geometry_x" `
	GeometryY      omitnull.Val[float64]   `db:"geometry_y" `
	LastEditedDate omitnull.Val[int64]     `db:"last_edited_date" `
	LastEditedUser omitnull.Val[string]    `db:"last_edited_user" `
	Version        omit.Val[int32]         `db:"version,pk" `
}

func (s HistoryTimecardSetter) SetColumns() []string {
	vals := make([]string, 0, 31)
	if !s.Activity.IsUnset() {
		vals = append(vals, "activity")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Enddatetime.IsUnset() {
		vals = append(vals, "enddatetime")
	}
	if !s.Equiptype.IsUnset() {
		vals = append(vals, "equiptype")
	}
	if !s.Externalid.IsUnset() {
		vals = append(vals, "externalid")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Fieldtech.IsUnset() {
		vals = append(vals, "fieldtech")
	}
	if !s.Globalid.IsUnset() {
		vals = append(vals, "globalid")
	}
	if !s.Lclocid.IsUnset() {
		vals = append(vals, "lclocid")
	}
	if !s.Linelocid.IsUnset() {
		vals = append(vals, "linelocid")
	}
	if !s.Locationname.IsUnset() {
		vals = append(vals, "locationname")
	}
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Pointlocid.IsUnset() {
		vals = append(vals, "pointlocid")
	}
	if !s.Polygonlocid.IsUnset() {
		vals = append(vals, "polygonlocid")
	}
	if !s.Samplelocid.IsUnset() {
		vals = append(vals, "samplelocid")
	}
	if !s.Srid.IsUnset() {
		vals = append(vals, "srid")
	}
	if !s.Startdatetime.IsUnset() {
		vals = append(vals, "startdatetime")
	}
	if !s.Traplocid.IsUnset() {
		vals = append(vals, "traplocid")
	}
	if !s.Zone.IsUnset() {
		vals = append(vals, "zone")
	}
	if !s.Zone2.IsUnset() {
		vals = append(vals, "zone2")
	}
	if !s.Created.IsUnset() {
		vals = append(vals, "created")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.GeometryX.IsUnset() {
		vals = append(vals, "geometry_x")
	}
	if !s.GeometryY.IsUnset() {
		vals = append(vals, "geometry_y")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	return vals
}

func (s HistoryTimecardSetter) Overwrite(t *HistoryTimecard) {
	if !s.Activity.IsUnset() {
		t.Activity = s.Activity.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Enddatetime.IsUnset() {
		t.Enddatetime = s.Enddatetime.MustGetNull()
	}
	if !s.Equiptype.IsUnset() {
		t.Equiptype = s.Equiptype.MustGetNull()
	}
	if !s.Externalid.IsUnset() {
		t.Externalid = s.Externalid.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Fieldtech.IsUnset() {
		t.Fieldtech = s.Fieldtech.MustGetNull()
	}
	if !s.Globalid.IsUnset() {
		t.Globalid = s.Globalid.MustGetNull()
	}
	if !s.Lclocid.IsUnset() {
		t.Lclocid = s.Lclocid.MustGetNull()
	}
	if !s.Linelocid.IsUnset() {
		t.Linelocid = s.Linelocid.MustGetNull()
	}
	if !s.Locationname.IsUnset() {
		t.Locationname = s.Locationname.MustGetNull()
	}
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Pointlocid.IsUnset() {
		t.Pointlocid = s.Pointlocid.MustGetNull()
	}
	if !s.Polygonlocid.IsUnset() {
		t.Polygonlocid = s.Polygonlocid.MustGetNull()
	}
	if !s.Samplelocid.IsUnset() {
		t.Samplelocid = s.Samplelocid.MustGetNull()
	}
	if !s.Srid.IsUnset() {
		t.Srid = s.Srid.MustGetNull()
	}
	if !s.Startdatetime.IsUnset() {
		t.Startdatetime = s.Startdatetime.MustGetNull()
	}
	if !s.Traplocid.IsUnset() {
		t.Traplocid = s.Traplocid.MustGetNull()
	}
	if !s.Zone.IsUnset() {
		t.Zone = s.Zone.MustGetNull()
	}
	if !s.Zone2.IsUnset() {
		t.Zone2 = s.Zone2.MustGetNull()
	}
	if !s.Created.IsUnset() {
		t.Created = s.Created.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.GeometryX.IsUnset() {
		t.GeometryX = s.GeometryX.MustGetNull()
	}
	if !s.GeometryY.IsUnset() {
		t.GeometryY = s.GeometryY.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
}

func (s *HistoryTimecardSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return HistoryTimecards.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 31)
		if !s.Activity.IsUnset() {
			vals[0] = psql.Arg(s.Activity.MustGetNull())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[1] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[2] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[3] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Enddatetime.IsUnset() {
			vals[4] = psql.Arg(s.Enddatetime.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Equiptype.IsUnset() {
			vals[5] = psql.Arg(s.Equiptype.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Externalid.IsUnset() {
			vals[6] = psql.Arg(s.Externalid.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[7] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[8] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Fieldtech.IsUnset() {
			vals[9] = psql.Arg(s.Fieldtech.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Globalid.IsUnset() {
			vals[10] = psql.Arg(s.Globalid.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Lclocid.IsUnset() {
			vals[11] = psql.Arg(s.Lclocid.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Linelocid.IsUnset() {
			vals[12] = psql.Arg(s.Linelocid.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Locationname.IsUnset() {
			vals[13] = psql.Arg(s.Locationname.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.Objectid.IsValue() {
			vals[14] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Pointlocid.IsUnset() {
			vals[15] = psql.Arg(s.Pointlocid.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Polygonlocid.IsUnset() {
			vals[16] = psql.Arg(s.Polygonlocid.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Samplelocid.IsUnset() {
			vals[17] = psql.Arg(s.Samplelocid.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Srid.IsUnset() {
			vals[18] = psql.Arg(s.Srid.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Startdatetime.IsUnset() {
			vals[19] = psql.Arg(s.Startdatetime.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.Traplocid.IsUnset() {
			vals[20] = psql.Arg(s.Traplocid.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Zone.IsUnset() {
			vals[21] = psql.Arg(s.Zone.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Zone2.IsUnset() {
			vals[22] = psql.Arg(s.Zone2.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Created.IsUnset() {
			vals[23] = psql.Arg(s.Created.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[24] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[25] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.GeometryX.IsUnset() {
			vals[26] = psql.Arg(s.GeometryX.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.GeometryY.IsUnset() {
			vals[27] = psql.Arg(s.GeometryY.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[28] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[29] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[30] = psql.Arg(s.Version.MustGet())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s HistoryTimecardSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s HistoryTimecardSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 31)

	if !s.Activity.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "activity")...),
			psql.Arg(s.Activity),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Enddatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "enddatetime")...),
			psql.Arg(s.Enddatetime),
		}})
	}

	if !s.Equiptype.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "equiptype")...),
			psql.Arg(s.Equiptype),
		}})
	}

	if !s.Externalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "externalid")...),
			psql.Arg(s.Externalid),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Fieldtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fieldtech")...),
			psql.Arg(s.Fieldtech),
		}})
	}

	if !s.Globalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Lclocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lclocid")...),
			psql.Arg(s.Lclocid),
		}})
	}

	if !s.Linelocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "linelocid")...),
			psql.Arg(s.Linelocid),
		}})
	}

	if !s.Locationname.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "locationname")...),
			psql.Arg(s.Locationname),
		}})
	}

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Pointlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pointlocid")...),
			psql.Arg(s.Pointlocid),
		}})
	}

	if !s.Polygonlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "polygonlocid")...),
			psql.Arg(s.Polygonlocid),
		}})
	}

	if !s.Samplelocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "samplelocid")...),
			psql.Arg(s.Samplelocid),
		}})
	}

	if !s.Srid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "srid")...),
			psql.Arg(s.Srid),
		}})
	}

	if !s.Startdatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "startdatetime")...),
			psql.Arg(s.Startdatetime),
		}})
	}

	if !s.Traplocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "traplocid")...),
			psql.Arg(s.Traplocid),
		}})
	}

	if !s.Zone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone")...),
			psql.Arg(s.Zone),
		}})
	}

	if !s.Zone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone2")...),
			psql.Arg(s.Zone2),
		}})
	}

	if !s.Created.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created")...),
			psql.Arg(s.Created),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.GeometryX.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_x")...),
			psql.Arg(s.GeometryX),
		}})
	}

	if !s.GeometryY.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_y")...),
			psql.Arg(s.GeometryY),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	return exprs
}

// FindHistoryTimecard retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindHistoryTimecard(ctx context.Context, exec bob.Executor, ObjectidPK int32, VersionPK int32, cols ...string) (*HistoryTimecard, error) {
	if len(cols) == 0 {
		return HistoryTimecards.Query(
			sm.Where(HistoryTimecards.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
			sm.Where(HistoryTimecards.Columns.Version.EQ(psql.Arg(VersionPK))),
		).One(ctx, exec)
	}

	return HistoryTimecards.Query(
		sm.Where(HistoryTimecards.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(HistoryTimecards.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Columns(HistoryTimecards.Columns.Only(cols...)),
	).One(ctx, exec)
}

// HistoryTimecardExists checks the presence of a single record by primary key
func HistoryTimecardExists(ctx context.Context, exec bob.Executor, ObjectidPK int32, VersionPK int32) (bool, error) {
	return HistoryTimecards.Query(
		sm.Where(HistoryTimecards.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(HistoryTimecards.Columns.Version.EQ(psql.Arg(VersionPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after HistoryTimecard is retrieved from the database
func (o *HistoryTimecard) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = HistoryTimecards.AfterSelectHooks.RunHooks(ctx, exec, HistoryTimecardSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = HistoryTimecards.AfterInsertHooks.RunHooks(ctx, exec, HistoryTimecardSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = HistoryTimecards.AfterUpdateHooks.RunHooks(ctx, exec, HistoryTimecardSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = HistoryTimecards.AfterDeleteHooks.RunHooks(ctx, exec, HistoryTimecardSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the HistoryTimecard
func (o *HistoryTimecard) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Objectid,
		o.Version,
	)
}

func (o *HistoryTimecard) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("history_timecard", "objectid"), psql.Quote("history_timecard", "version")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the HistoryTimecard
func (o *HistoryTimecard) Update(ctx context.Context, exec bob.Executor, s *HistoryTimecardSetter) error {
	v, err := HistoryTimecards.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *v

	return nil
}

// Delete deletes a single HistoryTimecard record with an executor
func (o *HistoryTimecard) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := HistoryTimecards.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the HistoryTimecard using the executor
func (o *HistoryTimecard) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := HistoryTimecards.Query(
		sm.Where(HistoryTimecards.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
		sm.Where(HistoryTimecards.Columns.Version.EQ(psql.Arg(o.Version))),
	).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

// AfterQueryHook is called after HistoryTimecardSlice is retrieved from the database
func (o HistoryTimecardSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = HistoryTimecards.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = HistoryTimecards.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = HistoryTimecards.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = HistoryTimecards.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o HistoryTimecardSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("history_timecard", "objectid"), psql.Quote("history_timecard", "version")).In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o HistoryTimecardSlice) copyMatchingRows(from ...*HistoryTimecard) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			if new.Version != old.Version {
				continue
			}

			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o HistoryTimecardSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return HistoryTimecards.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *HistoryTimecard:
				o.copyMatchingRows(retrieved)
			case []*HistoryTimecard:
				o.copyMatchingRows(retrieved...)
			case HistoryTimecardSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a HistoryTimecard or a slice of HistoryTimecard
				// then run the AfterUpdateHooks on the slice
				_, err = HistoryTimecards.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o HistoryTimecardSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return HistoryTimecards.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *HistoryTimecard:
				o.copyMatchingRows(retrieved)
			case []*HistoryTimecard:
				o.copyMatchingRows(retrieved...)
			case HistoryTimecardSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a HistoryTimecard or a slice of HistoryTimecard
				// then run the AfterDeleteHooks on the slice
				_, err = HistoryTimecards.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o HistoryTimecardSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals HistoryTimecardSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := HistoryTimecards.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o HistoryTimecardSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := HistoryTimecards.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o HistoryTimecardSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := HistoryTimecards.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type historyTimecardWhere[Q psql.Filterable] struct {
	Activity       psql.WhereNullMod[Q, string]
	Comments       psql.WhereNullMod[Q, string]
	Creationdate   psql.WhereNullMod[Q, int64]
	Creator        psql.WhereNullMod[Q, string]
	Enddatetime    psql.WhereNullMod[Q, int64]
	Equiptype      psql.WhereNullMod[Q, string]
	Externalid     psql.WhereNullMod[Q, string]
	Editdate       psql.WhereNullMod[Q, int64]
	Editor         psql.WhereNullMod[Q, string]
	Fieldtech      psql.WhereNullMod[Q, string]
	Globalid       psql.WhereNullMod[Q, string]
	Lclocid        psql.WhereNullMod[Q, string]
	Linelocid      psql.WhereNullMod[Q, string]
	Locationname   psql.WhereNullMod[Q, string]
	Objectid       psql.WhereMod[Q, int32]
	Pointlocid     psql.WhereNullMod[Q, string]
	Polygonlocid   psql.WhereNullMod[Q, string]
	Samplelocid    psql.WhereNullMod[Q, string]
	Srid           psql.WhereNullMod[Q, string]
	Startdatetime  psql.WhereNullMod[Q, int64]
	Traplocid      psql.WhereNullMod[Q, string]
	Zone           psql.WhereNullMod[Q, string]
	Zone2          psql.WhereNullMod[Q, string]
	Created        psql.WhereNullMod[Q, time.Time]
	CreatedDate    psql.WhereNullMod[Q, int64]
	CreatedUser    psql.WhereNullMod[Q, string]
	GeometryX      psql.WhereNullMod[Q, float64]
	GeometryY      psql.WhereNullMod[Q, float64]
	LastEditedDate psql.WhereNullMod[Q, int64]
	LastEditedUser psql.WhereNullMod[Q, string]
	Version        psql.WhereMod[Q, int32]
}

func (historyTimecardWhere[Q]) AliasedAs(alias string) historyTimecardWhere[Q] {
	return buildHistoryTimecardWhere[Q](buildHistoryTimecardColumns(alias))
}

func buildHistoryTimecardWhere[Q psql.Filterable](cols historyTimecardColumns) historyTimecardWhere[Q] {
	return historyTimecardWhere[Q]{
		Activity:       psql.WhereNull[Q, string](cols.Activity),
		Comments:       psql.WhereNull[Q, string](cols.Comments),
		Creationdate:   psql.WhereNull[Q, int64](cols.Creationdate),
		Creator:        psql.WhereNull[Q, string](cols.Creator),
		Enddatetime:    psql.WhereNull[Q, int64](cols.Enddatetime),
		Equiptype:      psql.WhereNull[Q, string](cols.Equiptype),
		Externalid:     psql.WhereNull[Q, string](cols.Externalid),
		Editdate:       psql.WhereNull[Q, int64](cols.Editdate),
		Editor:         psql.WhereNull[Q, string](cols.Editor),
		Fieldtech:      psql.WhereNull[Q, string](cols.Fieldtech),
		Globalid:       psql.WhereNull[Q, string](cols.Globalid),
		Lclocid:        psql.WhereNull[Q, string](cols.Lclocid),
		Linelocid:      psql.WhereNull[Q, string](cols.Linelocid),
		Locationname:   psql.WhereNull[Q, string](cols.Locationname),
		Objectid:       psql.Where[Q, int32](cols.Objectid),
		Pointlocid:     psql.WhereNull[Q, string](cols.Pointlocid),
		Polygonlocid:   psql.WhereNull[Q, string](cols.Polygonlocid),
		Samplelocid:    psql.WhereNull[Q, string](cols.Samplelocid),
		Srid:           psql.WhereNull[Q, string](cols.Srid),
		Startdatetime:  psql.WhereNull[Q, int64](cols.Startdatetime),
		Traplocid:      psql.WhereNull[Q, string](cols.Traplocid),
		Zone:           psql.WhereNull[Q, string](cols.Zone),
		Zone2:          psql.WhereNull[Q, string](cols.Zone2),
		Created:        psql.WhereNull[Q, time.Time](cols.Created),
		CreatedDate:    psql.WhereNull[Q, int64](cols.CreatedDate),
		CreatedUser:    psql.WhereNull[Q, string](cols.CreatedUser),
		GeometryX:      psql.WhereNull[Q, float64](cols.GeometryX),
		GeometryY:      psql.WhereNull[Q, float64](cols.GeometryY),
		LastEditedDate: psql.WhereNull[Q, int64](cols.LastEditedDate),
		LastEditedUser: psql.WhereNull[Q, string](cols.LastEditedUser),
		Version:        psql.Where[Q, int32](cols.Version),
	}
}
