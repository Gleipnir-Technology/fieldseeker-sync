// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
)

// FSPool is an object representing the database table.
type FSPool struct {
	Comments               null.Val[string]  `db:"comments" `
	Creationdate           null.Val[int64]   `db:"creationdate" `
	Creator                null.Val[string]  `db:"creator" `
	Datesent               null.Val[int64]   `db:"datesent" `
	Datetested             null.Val[int64]   `db:"datetested" `
	Diseasepos             null.Val[string]  `db:"diseasepos" `
	Diseasetested          null.Val[string]  `db:"diseasetested" `
	Editdate               null.Val[int64]   `db:"editdate" `
	Editor                 null.Val[string]  `db:"editor" `
	Gatewaysync            null.Val[int16]   `db:"gatewaysync" `
	Globalid               null.Val[string]  `db:"globalid" `
	Lab                    null.Val[string]  `db:"lab" `
	LabID                  null.Val[string]  `db:"lab_id" `
	Objectid               int32             `db:"objectid,pk" `
	Poolyear               null.Val[int16]   `db:"poolyear" `
	Processed              null.Val[int16]   `db:"processed" `
	Sampleid               null.Val[string]  `db:"sampleid" `
	Survtech               null.Val[string]  `db:"survtech" `
	Testmethod             null.Val[string]  `db:"testmethod" `
	Testtech               null.Val[string]  `db:"testtech" `
	TrapdataID             null.Val[string]  `db:"trapdata_id" `
	CreatedDate            null.Val[int64]   `db:"created_date" `
	CreatedUser            null.Val[string]  `db:"created_user" `
	GeometryX              null.Val[float64] `db:"geometry_x" `
	GeometryY              null.Val[float64] `db:"geometry_y" `
	LastEditedDate         null.Val[int64]   `db:"last_edited_date" `
	LastEditedUser         null.Val[string]  `db:"last_edited_user" `
	Vectorsurvcollectionid null.Val[string]  `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       null.Val[string]  `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   null.Val[string]  `db:"vectorsurvtrapdataid" `
	Updated                time.Time         `db:"updated" `
}

// FSPoolSlice is an alias for a slice of pointers to FSPool.
// This should almost always be used instead of []*FSPool.
type FSPoolSlice []*FSPool

// FSPools contains methods to work with the fs_pool table
var FSPools = psql.NewTablex[*FSPool, FSPoolSlice, *FSPoolSetter]("", "fs_pool", buildFSPoolColumns("fs_pool"))

// FSPoolsQuery is a query on the fs_pool table
type FSPoolsQuery = *psql.ViewQuery[*FSPool, FSPoolSlice]

func buildFSPoolColumns(alias string) fsPoolColumns {
	return fsPoolColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"comments", "creationdate", "creator", "datesent", "datetested", "diseasepos", "diseasetested", "editdate", "editor", "gatewaysync", "globalid", "lab", "lab_id", "objectid", "poolyear", "processed", "sampleid", "survtech", "testmethod", "testtech", "trapdata_id", "created_date", "created_user", "geometry_x", "geometry_y", "last_edited_date", "last_edited_user", "vectorsurvcollectionid", "vectorsurvpoolid", "vectorsurvtrapdataid", "updated",
		).WithParent("fs_pool"),
		tableAlias:             alias,
		Comments:               psql.Quote(alias, "comments"),
		Creationdate:           psql.Quote(alias, "creationdate"),
		Creator:                psql.Quote(alias, "creator"),
		Datesent:               psql.Quote(alias, "datesent"),
		Datetested:             psql.Quote(alias, "datetested"),
		Diseasepos:             psql.Quote(alias, "diseasepos"),
		Diseasetested:          psql.Quote(alias, "diseasetested"),
		Editdate:               psql.Quote(alias, "editdate"),
		Editor:                 psql.Quote(alias, "editor"),
		Gatewaysync:            psql.Quote(alias, "gatewaysync"),
		Globalid:               psql.Quote(alias, "globalid"),
		Lab:                    psql.Quote(alias, "lab"),
		LabID:                  psql.Quote(alias, "lab_id"),
		Objectid:               psql.Quote(alias, "objectid"),
		Poolyear:               psql.Quote(alias, "poolyear"),
		Processed:              psql.Quote(alias, "processed"),
		Sampleid:               psql.Quote(alias, "sampleid"),
		Survtech:               psql.Quote(alias, "survtech"),
		Testmethod:             psql.Quote(alias, "testmethod"),
		Testtech:               psql.Quote(alias, "testtech"),
		TrapdataID:             psql.Quote(alias, "trapdata_id"),
		CreatedDate:            psql.Quote(alias, "created_date"),
		CreatedUser:            psql.Quote(alias, "created_user"),
		GeometryX:              psql.Quote(alias, "geometry_x"),
		GeometryY:              psql.Quote(alias, "geometry_y"),
		LastEditedDate:         psql.Quote(alias, "last_edited_date"),
		LastEditedUser:         psql.Quote(alias, "last_edited_user"),
		Vectorsurvcollectionid: psql.Quote(alias, "vectorsurvcollectionid"),
		Vectorsurvpoolid:       psql.Quote(alias, "vectorsurvpoolid"),
		Vectorsurvtrapdataid:   psql.Quote(alias, "vectorsurvtrapdataid"),
		Updated:                psql.Quote(alias, "updated"),
	}
}

type fsPoolColumns struct {
	expr.ColumnsExpr
	tableAlias             string
	Comments               psql.Expression
	Creationdate           psql.Expression
	Creator                psql.Expression
	Datesent               psql.Expression
	Datetested             psql.Expression
	Diseasepos             psql.Expression
	Diseasetested          psql.Expression
	Editdate               psql.Expression
	Editor                 psql.Expression
	Gatewaysync            psql.Expression
	Globalid               psql.Expression
	Lab                    psql.Expression
	LabID                  psql.Expression
	Objectid               psql.Expression
	Poolyear               psql.Expression
	Processed              psql.Expression
	Sampleid               psql.Expression
	Survtech               psql.Expression
	Testmethod             psql.Expression
	Testtech               psql.Expression
	TrapdataID             psql.Expression
	CreatedDate            psql.Expression
	CreatedUser            psql.Expression
	GeometryX              psql.Expression
	GeometryY              psql.Expression
	LastEditedDate         psql.Expression
	LastEditedUser         psql.Expression
	Vectorsurvcollectionid psql.Expression
	Vectorsurvpoolid       psql.Expression
	Vectorsurvtrapdataid   psql.Expression
	Updated                psql.Expression
}

func (c fsPoolColumns) Alias() string {
	return c.tableAlias
}

func (fsPoolColumns) AliasedAs(alias string) fsPoolColumns {
	return buildFSPoolColumns(alias)
}

// FSPoolSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FSPoolSetter struct {
	Comments               omitnull.Val[string]  `db:"comments" `
	Creationdate           omitnull.Val[int64]   `db:"creationdate" `
	Creator                omitnull.Val[string]  `db:"creator" `
	Datesent               omitnull.Val[int64]   `db:"datesent" `
	Datetested             omitnull.Val[int64]   `db:"datetested" `
	Diseasepos             omitnull.Val[string]  `db:"diseasepos" `
	Diseasetested          omitnull.Val[string]  `db:"diseasetested" `
	Editdate               omitnull.Val[int64]   `db:"editdate" `
	Editor                 omitnull.Val[string]  `db:"editor" `
	Gatewaysync            omitnull.Val[int16]   `db:"gatewaysync" `
	Globalid               omitnull.Val[string]  `db:"globalid" `
	Lab                    omitnull.Val[string]  `db:"lab" `
	LabID                  omitnull.Val[string]  `db:"lab_id" `
	Objectid               omit.Val[int32]       `db:"objectid,pk" `
	Poolyear               omitnull.Val[int16]   `db:"poolyear" `
	Processed              omitnull.Val[int16]   `db:"processed" `
	Sampleid               omitnull.Val[string]  `db:"sampleid" `
	Survtech               omitnull.Val[string]  `db:"survtech" `
	Testmethod             omitnull.Val[string]  `db:"testmethod" `
	Testtech               omitnull.Val[string]  `db:"testtech" `
	TrapdataID             omitnull.Val[string]  `db:"trapdata_id" `
	CreatedDate            omitnull.Val[int64]   `db:"created_date" `
	CreatedUser            omitnull.Val[string]  `db:"created_user" `
	GeometryX              omitnull.Val[float64] `db:"geometry_x" `
	GeometryY              omitnull.Val[float64] `db:"geometry_y" `
	LastEditedDate         omitnull.Val[int64]   `db:"last_edited_date" `
	LastEditedUser         omitnull.Val[string]  `db:"last_edited_user" `
	Vectorsurvcollectionid omitnull.Val[string]  `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       omitnull.Val[string]  `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   omitnull.Val[string]  `db:"vectorsurvtrapdataid" `
	Updated                omit.Val[time.Time]   `db:"updated" `
}

func (s FSPoolSetter) SetColumns() []string {
	vals := make([]string, 0, 31)
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Datesent.IsUnset() {
		vals = append(vals, "datesent")
	}
	if !s.Datetested.IsUnset() {
		vals = append(vals, "datetested")
	}
	if !s.Diseasepos.IsUnset() {
		vals = append(vals, "diseasepos")
	}
	if !s.Diseasetested.IsUnset() {
		vals = append(vals, "diseasetested")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Gatewaysync.IsUnset() {
		vals = append(vals, "gatewaysync")
	}
	if !s.Globalid.IsUnset() {
		vals = append(vals, "globalid")
	}
	if !s.Lab.IsUnset() {
		vals = append(vals, "lab")
	}
	if !s.LabID.IsUnset() {
		vals = append(vals, "lab_id")
	}
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Poolyear.IsUnset() {
		vals = append(vals, "poolyear")
	}
	if !s.Processed.IsUnset() {
		vals = append(vals, "processed")
	}
	if !s.Sampleid.IsUnset() {
		vals = append(vals, "sampleid")
	}
	if !s.Survtech.IsUnset() {
		vals = append(vals, "survtech")
	}
	if !s.Testmethod.IsUnset() {
		vals = append(vals, "testmethod")
	}
	if !s.Testtech.IsUnset() {
		vals = append(vals, "testtech")
	}
	if !s.TrapdataID.IsUnset() {
		vals = append(vals, "trapdata_id")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.GeometryX.IsUnset() {
		vals = append(vals, "geometry_x")
	}
	if !s.GeometryY.IsUnset() {
		vals = append(vals, "geometry_y")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		vals = append(vals, "vectorsurvcollectionid")
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		vals = append(vals, "vectorsurvpoolid")
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		vals = append(vals, "vectorsurvtrapdataid")
	}
	if s.Updated.IsValue() {
		vals = append(vals, "updated")
	}
	return vals
}

func (s FSPoolSetter) Overwrite(t *FSPool) {
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Datesent.IsUnset() {
		t.Datesent = s.Datesent.MustGetNull()
	}
	if !s.Datetested.IsUnset() {
		t.Datetested = s.Datetested.MustGetNull()
	}
	if !s.Diseasepos.IsUnset() {
		t.Diseasepos = s.Diseasepos.MustGetNull()
	}
	if !s.Diseasetested.IsUnset() {
		t.Diseasetested = s.Diseasetested.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Gatewaysync.IsUnset() {
		t.Gatewaysync = s.Gatewaysync.MustGetNull()
	}
	if !s.Globalid.IsUnset() {
		t.Globalid = s.Globalid.MustGetNull()
	}
	if !s.Lab.IsUnset() {
		t.Lab = s.Lab.MustGetNull()
	}
	if !s.LabID.IsUnset() {
		t.LabID = s.LabID.MustGetNull()
	}
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Poolyear.IsUnset() {
		t.Poolyear = s.Poolyear.MustGetNull()
	}
	if !s.Processed.IsUnset() {
		t.Processed = s.Processed.MustGetNull()
	}
	if !s.Sampleid.IsUnset() {
		t.Sampleid = s.Sampleid.MustGetNull()
	}
	if !s.Survtech.IsUnset() {
		t.Survtech = s.Survtech.MustGetNull()
	}
	if !s.Testmethod.IsUnset() {
		t.Testmethod = s.Testmethod.MustGetNull()
	}
	if !s.Testtech.IsUnset() {
		t.Testtech = s.Testtech.MustGetNull()
	}
	if !s.TrapdataID.IsUnset() {
		t.TrapdataID = s.TrapdataID.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.GeometryX.IsUnset() {
		t.GeometryX = s.GeometryX.MustGetNull()
	}
	if !s.GeometryY.IsUnset() {
		t.GeometryY = s.GeometryY.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		t.Vectorsurvcollectionid = s.Vectorsurvcollectionid.MustGetNull()
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		t.Vectorsurvpoolid = s.Vectorsurvpoolid.MustGetNull()
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		t.Vectorsurvtrapdataid = s.Vectorsurvtrapdataid.MustGetNull()
	}
	if s.Updated.IsValue() {
		t.Updated = s.Updated.MustGet()
	}
}

func (s *FSPoolSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FSPools.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 31)
		if !s.Comments.IsUnset() {
			vals[0] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[1] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[2] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Datesent.IsUnset() {
			vals[3] = psql.Arg(s.Datesent.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Datetested.IsUnset() {
			vals[4] = psql.Arg(s.Datetested.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Diseasepos.IsUnset() {
			vals[5] = psql.Arg(s.Diseasepos.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Diseasetested.IsUnset() {
			vals[6] = psql.Arg(s.Diseasetested.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[7] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[8] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Gatewaysync.IsUnset() {
			vals[9] = psql.Arg(s.Gatewaysync.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Globalid.IsUnset() {
			vals[10] = psql.Arg(s.Globalid.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Lab.IsUnset() {
			vals[11] = psql.Arg(s.Lab.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.LabID.IsUnset() {
			vals[12] = psql.Arg(s.LabID.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.Objectid.IsValue() {
			vals[13] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Poolyear.IsUnset() {
			vals[14] = psql.Arg(s.Poolyear.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Processed.IsUnset() {
			vals[15] = psql.Arg(s.Processed.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Sampleid.IsUnset() {
			vals[16] = psql.Arg(s.Sampleid.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Survtech.IsUnset() {
			vals[17] = psql.Arg(s.Survtech.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Testmethod.IsUnset() {
			vals[18] = psql.Arg(s.Testmethod.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Testtech.IsUnset() {
			vals[19] = psql.Arg(s.Testtech.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.TrapdataID.IsUnset() {
			vals[20] = psql.Arg(s.TrapdataID.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[21] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[22] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.GeometryX.IsUnset() {
			vals[23] = psql.Arg(s.GeometryX.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.GeometryY.IsUnset() {
			vals[24] = psql.Arg(s.GeometryY.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[25] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[26] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvcollectionid.IsUnset() {
			vals[27] = psql.Arg(s.Vectorsurvcollectionid.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvpoolid.IsUnset() {
			vals[28] = psql.Arg(s.Vectorsurvpoolid.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvtrapdataid.IsUnset() {
			vals[29] = psql.Arg(s.Vectorsurvtrapdataid.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if s.Updated.IsValue() {
			vals[30] = psql.Arg(s.Updated.MustGet())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FSPoolSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FSPoolSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 31)

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Datesent.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datesent")...),
			psql.Arg(s.Datesent),
		}})
	}

	if !s.Datetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datetested")...),
			psql.Arg(s.Datetested),
		}})
	}

	if !s.Diseasepos.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasepos")...),
			psql.Arg(s.Diseasepos),
		}})
	}

	if !s.Diseasetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasetested")...),
			psql.Arg(s.Diseasetested),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Gatewaysync.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gatewaysync")...),
			psql.Arg(s.Gatewaysync),
		}})
	}

	if !s.Globalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Lab.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab")...),
			psql.Arg(s.Lab),
		}})
	}

	if !s.LabID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab_id")...),
			psql.Arg(s.LabID),
		}})
	}

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Poolyear.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "poolyear")...),
			psql.Arg(s.Poolyear),
		}})
	}

	if !s.Processed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "processed")...),
			psql.Arg(s.Processed),
		}})
	}

	if !s.Sampleid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sampleid")...),
			psql.Arg(s.Sampleid),
		}})
	}

	if !s.Survtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "survtech")...),
			psql.Arg(s.Survtech),
		}})
	}

	if !s.Testmethod.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testmethod")...),
			psql.Arg(s.Testmethod),
		}})
	}

	if !s.Testtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testtech")...),
			psql.Arg(s.Testtech),
		}})
	}

	if !s.TrapdataID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "trapdata_id")...),
			psql.Arg(s.TrapdataID),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.GeometryX.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_x")...),
			psql.Arg(s.GeometryX),
		}})
	}

	if !s.GeometryY.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_y")...),
			psql.Arg(s.GeometryY),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if !s.Vectorsurvcollectionid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvcollectionid")...),
			psql.Arg(s.Vectorsurvcollectionid),
		}})
	}

	if !s.Vectorsurvpoolid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvpoolid")...),
			psql.Arg(s.Vectorsurvpoolid),
		}})
	}

	if !s.Vectorsurvtrapdataid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvtrapdataid")...),
			psql.Arg(s.Vectorsurvtrapdataid),
		}})
	}

	if s.Updated.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated")...),
			psql.Arg(s.Updated),
		}})
	}

	return exprs
}

// FindFSPool retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFSPool(ctx context.Context, exec bob.Executor, ObjectidPK int32, cols ...string) (*FSPool, error) {
	if len(cols) == 0 {
		return FSPools.Query(
			sm.Where(FSPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		).One(ctx, exec)
	}

	return FSPools.Query(
		sm.Where(FSPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Columns(FSPools.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FSPoolExists checks the presence of a single record by primary key
func FSPoolExists(ctx context.Context, exec bob.Executor, ObjectidPK int32) (bool, error) {
	return FSPools.Query(
		sm.Where(FSPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FSPool is retrieved from the database
func (o *FSPool) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSPools.AfterSelectHooks.RunHooks(ctx, exec, FSPoolSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FSPools.AfterInsertHooks.RunHooks(ctx, exec, FSPoolSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FSPools.AfterUpdateHooks.RunHooks(ctx, exec, FSPoolSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FSPools.AfterDeleteHooks.RunHooks(ctx, exec, FSPoolSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FSPool
func (o *FSPool) primaryKeyVals() bob.Expression {
	return psql.Arg(o.Objectid)
}

func (o *FSPool) pkEQ() dialect.Expression {
	return psql.Quote("fs_pool", "objectid").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FSPool
func (o *FSPool) Update(ctx context.Context, exec bob.Executor, s *FSPoolSetter) error {
	v, err := FSPools.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *v

	return nil
}

// Delete deletes a single FSPool record with an executor
func (o *FSPool) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FSPools.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FSPool using the executor
func (o *FSPool) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FSPools.Query(
		sm.Where(FSPools.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
	).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

// AfterQueryHook is called after FSPoolSlice is retrieved from the database
func (o FSPoolSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSPools.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FSPools.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FSPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FSPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FSPoolSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("fs_pool", "objectid").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FSPoolSlice) copyMatchingRows(from ...*FSPool) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}

			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FSPoolSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSPools.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSPool:
				o.copyMatchingRows(retrieved)
			case []*FSPool:
				o.copyMatchingRows(retrieved...)
			case FSPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSPool or a slice of FSPool
				// then run the AfterUpdateHooks on the slice
				_, err = FSPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FSPoolSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSPools.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSPool:
				o.copyMatchingRows(retrieved)
			case []*FSPool:
				o.copyMatchingRows(retrieved...)
			case FSPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSPool or a slice of FSPool
				// then run the AfterDeleteHooks on the slice
				_, err = FSPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FSPoolSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FSPoolSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSPools.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FSPoolSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSPools.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FSPoolSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FSPools.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type fsPoolWhere[Q psql.Filterable] struct {
	Comments               psql.WhereNullMod[Q, string]
	Creationdate           psql.WhereNullMod[Q, int64]
	Creator                psql.WhereNullMod[Q, string]
	Datesent               psql.WhereNullMod[Q, int64]
	Datetested             psql.WhereNullMod[Q, int64]
	Diseasepos             psql.WhereNullMod[Q, string]
	Diseasetested          psql.WhereNullMod[Q, string]
	Editdate               psql.WhereNullMod[Q, int64]
	Editor                 psql.WhereNullMod[Q, string]
	Gatewaysync            psql.WhereNullMod[Q, int16]
	Globalid               psql.WhereNullMod[Q, string]
	Lab                    psql.WhereNullMod[Q, string]
	LabID                  psql.WhereNullMod[Q, string]
	Objectid               psql.WhereMod[Q, int32]
	Poolyear               psql.WhereNullMod[Q, int16]
	Processed              psql.WhereNullMod[Q, int16]
	Sampleid               psql.WhereNullMod[Q, string]
	Survtech               psql.WhereNullMod[Q, string]
	Testmethod             psql.WhereNullMod[Q, string]
	Testtech               psql.WhereNullMod[Q, string]
	TrapdataID             psql.WhereNullMod[Q, string]
	CreatedDate            psql.WhereNullMod[Q, int64]
	CreatedUser            psql.WhereNullMod[Q, string]
	GeometryX              psql.WhereNullMod[Q, float64]
	GeometryY              psql.WhereNullMod[Q, float64]
	LastEditedDate         psql.WhereNullMod[Q, int64]
	LastEditedUser         psql.WhereNullMod[Q, string]
	Vectorsurvcollectionid psql.WhereNullMod[Q, string]
	Vectorsurvpoolid       psql.WhereNullMod[Q, string]
	Vectorsurvtrapdataid   psql.WhereNullMod[Q, string]
	Updated                psql.WhereMod[Q, time.Time]
}

func (fsPoolWhere[Q]) AliasedAs(alias string) fsPoolWhere[Q] {
	return buildFSPoolWhere[Q](buildFSPoolColumns(alias))
}

func buildFSPoolWhere[Q psql.Filterable](cols fsPoolColumns) fsPoolWhere[Q] {
	return fsPoolWhere[Q]{
		Comments:               psql.WhereNull[Q, string](cols.Comments),
		Creationdate:           psql.WhereNull[Q, int64](cols.Creationdate),
		Creator:                psql.WhereNull[Q, string](cols.Creator),
		Datesent:               psql.WhereNull[Q, int64](cols.Datesent),
		Datetested:             psql.WhereNull[Q, int64](cols.Datetested),
		Diseasepos:             psql.WhereNull[Q, string](cols.Diseasepos),
		Diseasetested:          psql.WhereNull[Q, string](cols.Diseasetested),
		Editdate:               psql.WhereNull[Q, int64](cols.Editdate),
		Editor:                 psql.WhereNull[Q, string](cols.Editor),
		Gatewaysync:            psql.WhereNull[Q, int16](cols.Gatewaysync),
		Globalid:               psql.WhereNull[Q, string](cols.Globalid),
		Lab:                    psql.WhereNull[Q, string](cols.Lab),
		LabID:                  psql.WhereNull[Q, string](cols.LabID),
		Objectid:               psql.Where[Q, int32](cols.Objectid),
		Poolyear:               psql.WhereNull[Q, int16](cols.Poolyear),
		Processed:              psql.WhereNull[Q, int16](cols.Processed),
		Sampleid:               psql.WhereNull[Q, string](cols.Sampleid),
		Survtech:               psql.WhereNull[Q, string](cols.Survtech),
		Testmethod:             psql.WhereNull[Q, string](cols.Testmethod),
		Testtech:               psql.WhereNull[Q, string](cols.Testtech),
		TrapdataID:             psql.WhereNull[Q, string](cols.TrapdataID),
		CreatedDate:            psql.WhereNull[Q, int64](cols.CreatedDate),
		CreatedUser:            psql.WhereNull[Q, string](cols.CreatedUser),
		GeometryX:              psql.WhereNull[Q, float64](cols.GeometryX),
		GeometryY:              psql.WhereNull[Q, float64](cols.GeometryY),
		LastEditedDate:         psql.WhereNull[Q, int64](cols.LastEditedDate),
		LastEditedUser:         psql.WhereNull[Q, string](cols.LastEditedUser),
		Vectorsurvcollectionid: psql.WhereNull[Q, string](cols.Vectorsurvcollectionid),
		Vectorsurvpoolid:       psql.WhereNull[Q, string](cols.Vectorsurvpoolid),
		Vectorsurvtrapdataid:   psql.WhereNull[Q, string](cols.Vectorsurvtrapdataid),
		Updated:                psql.Where[Q, time.Time](cols.Updated),
	}
}
